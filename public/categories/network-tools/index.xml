<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JUMPSEC – Network-Tools</title>
    <link>//localhost:1313/categories/network-tools/</link>
    <description>Recent content in Network-Tools on JUMPSEC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <lastBuildDate>Fri, 09 Jun 2023 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="//localhost:1313/categories/network-tools/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Ligolo: Quality of Life on Red Team Engagements</title>
      <link>//localhost:1313/articles/2023/06/2023-06-09-ligolo-quality-of-life-on-red-team-engagements/</link>
      <pubDate>Fri, 09 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2023/06/2023-06-09-ligolo-quality-of-life-on-red-team-engagements/</guid>
      <description>
        
        
        &lt;p&gt;**&lt;figure&gt;
    &lt;img src=&#34;images/ligolo-bugsbunny-2023-06-09_12-50-300x267.png&#34; title=&#34;ligolo bugsbunny 2023 06 09 12 50&#34; alt=&#34;ligolo bugsbunny 2023 06 09 12 50&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;ligolo bugsbunny 2023 06 09 12 50&lt;/figcaption&gt;
  &lt;/figure&gt;**In recent months we, JUMPSEC’s red team, have been using a nifty little tool that we would like to share with you in this blog post. Ligolo-ng is a versatile tool that has been aiding our covert, and slightly-less-covert, engagements with regards to tunnelling, exfiltration, persistence, and widely improving the operators’ “quality of life” when carrying out assessments involving beaconing from within an internal network.&lt;/p&gt;
&lt;p&gt;This highly-useful tool is developed by Nicolas Chatelain and can be found on Github at &lt;a href=&#34;https://github.com/nicocha30/ligolo-ng&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/nicocha30/ligolo-ng&lt;/a&gt;. Ligolo can be described as a modern tunnelling tool, similar to the likes of chisel, sshuttle or SSH, with the advantage of being written in GO and behaving just like a VPN. That is to say, when setup correctly operators can enjoy connections to a target network of up to 100 Mbits/sec, utilising various protocols such as ICMP (ping), UDP scans, SYN stealth scan, OS detection and DNS Resolution, which are commonly not allowed through proxychains or “standard” tunnelling tooling.&lt;/p&gt;
&lt;p&gt;The tool uses agents on the compromised machine which connect to a publicly-facing proxy server to route traffic through a tun interface that is created on the host. In simple terms, Ligolo offers red teamers an alternative C2 channel that supports far more than traditional SSH or SOCKS proxies, allowing you to run a wider variety of tooling, much faster, and with what feels like too-good-to-be-true quality of life.&lt;/p&gt;
&lt;p&gt;The gif below shows how quick it is to setup the proxy server on a linux host machine after downloading the proxy executable from the releases’ page on Github.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/latest_ligolo_demo_setup5.gif&#34; title=&#34;latest ligolo demo setup5&#34; alt=&#34;latest ligolo demo setup5&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;latest ligolo demo setup5&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;More and more, when using this tool, we discover features applicable to new use-cases. For example, beside its ease of use, things like using ping and private domain name resolution during a red team engagement are invaluable and can definitely improve the turnaround time and efficiency of an assessment. Once the necessary steps have been taken, as detailed below, operators can enjoy their entire suite of red team tooling on their linux server, with full name resolution, and speeds that are incomparable with that of traditional tunnelling on red team engagements. We have jokingly referred to Ligolo as allowing you to move your C2 into the target network!&lt;/p&gt;
&lt;p&gt;Furthermore, it is possible to set up listeners on deployed agents to welcome connections coming from agents deployed somewhere else in the target environment. Crucially, the agents do not require any privileged permissions to be executed on the compromised hosts, because of its “gvisor” implementation, which works by virtualising sandboxed containers that translate traffic reaching the central proxy server deployed on our host.&lt;/p&gt;
&lt;p&gt;As previously mentioned, GO makes it highly versatile and flexible, allowing operators to customise the proxy as well as the agents, and compile them to bypass defences or implement additional capabilities that are not there by default.&lt;/p&gt;
&lt;p&gt;For example, we found ourselves able to bypass common endpoint detection and response (EDR) mechanisms employed in a Windows environment by simply either packing the agent executable (something like Nimcrypt will do), removing unimportant pieces of code, restructuring the source-code, or by compiling the agents beforehand and adding extra flags to the syntax, such as the following:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GOOS=windows GOARCH=amd64 go build -ldflags=&amp;quot;-s -w&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Researchers at JUMPSEC have also recently determined that, in at least several mature client environments, the creation of new network interfaces is not monitored. Therefore, should you find yourself wanting to deploy a Ligolo proxy server on a compromised machine (remember you don’t need admin permissions to deploy an agent but you do need it to deploy a proxy server!), and that it does not appear that monitoring is in place for tunnelling tools such as Ligolo by default, which makes it an attractive target when compared to existing C2 payloads. A note of caution however, EDRs may flag the “tunnelling” functionality when traffic is exchanged between the agent and the proxy.&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;
    &lt;img src=&#34;images/fry-takemymoney-300x300.png&#34; title=&#34;fry takemymoney&#34; alt=&#34;fry takemymoney&#34; loading=&#34;lazy&#34; /&gt;
    &lt;figcaption&gt;fry takemymoney&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Once a successful connection has been established packets will be automatically (read automagically) routed to the intended target network, making it a seamless experience, and one that compares with the ease of which you would carry out operations in your own local network.&lt;/p&gt;
&lt;p&gt;The agents can be easily modified and trivially executed by a Scheduled Task or a Cron Job for backdoor purposes or to establish persistence. When trying to achieve domain dominance on an engagement we found we were having to spend far less time in fixing or maintaining our foothold when compared to the usual routines of dealing with beacons, port forwarding and SSH tunnelling. Furthermore, we found that generally there are less restrictions in regards to the traffic we are allowed to generate and forward through.&lt;/p&gt;
&lt;p&gt;As previously mentioned, another interesting capability of this tool is the possibility to create listeners on the agent themselves to chain connections as shown in the code block below.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;[Agent : domain\Administrator@VICTIM] &amp;gt;&amp;gt; listener_add --addr &amp;lt;agent_ip&amp;gt;:11601 --to &amp;lt;proxyserver_ip&amp;gt;:11601
INFO[0326] Listener created on remote agent!&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This behaviour is particularly useful when the proxy server’s IP address is out of reach for the last deployed agent, but connection can be established from the final pivoted box to the adjacent network running a previously deployed ligolo’s agent, allowing a pass-through connection back to our proxy server leveraged by the agent listener/forwarder.&lt;/p&gt;
&lt;p&gt;Finally, some caveats to keep in consideration…Ligolo does not automatically recognise the subnets where traffic needs to be redirected to, therefore you will need to add your routes as you discover or need them, using something like “sudo ip route add 192.168.0.0/24 dev ligolo” on the proxy server’s host, and target’s nameservers to /etc/resolv.conf to use DNS instead of IP addresses in an internal network. Furthermore, do not expect your agents to automatically establish a tunnel when reconnecting to the proxy…an auto-connect feature needs to be developed in-house or wait for the feature to be released by the author. Finally, remember that when using it for client networks, you will need a publicly facing box reachable by the agents to listen for connections and execute commands from.&lt;/p&gt;
&lt;p&gt;All in all, Ligolo enabled us to speed up our engagements, made our shells more stable and reliable, allowed for a larger and more comprehensive gathering of our targets data, and helped us spend less time maintaining an important part of our persistent operational infrastructure. Most importantly, it avoids the use of tooling on-disk or even in memory, as only the raw traffic leaves the compromised machine.&lt;/p&gt;
&lt;p&gt;To conclude this blogpost, I just want to say (write) that we love Ligolo and we are very grateful to Nicolas Chatelain for creating this amazing instrument that we are proud to have in our day-to-day operational tool suite.&lt;/p&gt;
&lt;p&gt;References&lt;/p&gt;
&lt;p&gt;● The Cyber Plumber&amp;rsquo;s Handbook - &lt;a href=&#34;https://github.com/opsdisk/the&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/opsdisk/the&lt;/a&gt;_cyber_plumbers_handbook&lt;/p&gt;
&lt;p&gt;● Ligolo-ng - &lt;a href=&#34;https://github.com/nicocha30/ligolo-ng&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/nicocha30/ligolo-ng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;● Gvisor - &lt;a href=&#34;https://gvisor.dev/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gvisor.dev/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Alternatives to Ligolo-ng:&lt;/p&gt;
&lt;p&gt;● Proxychains - &lt;a href=&#34;https://github.com/haad/proxychains&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/haad/proxychains&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;● Proxychains-ng - &lt;a href=&#34;https://github.com/rofl0r/proxychains-ng&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/rofl0r/proxychains-ng&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;● Chisel - &lt;a href=&#34;https://github.com/jpillora/chisel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/jpillora/chisel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;● SSHuttle - &lt;a href=&#34;https://github.com/sshuttle/sshuttle&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/sshuttle/sshuttle&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Burp Suite and Beyond: Exploring non-HTTP protocols using MITM_RELAY</title>
      <link>//localhost:1313/articles/2021/08/2021-08-24-burpsuite-and-beyond/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2021/08/2021-08-24-burpsuite-and-beyond/</guid>
      <description>
        
        
        &lt;p&gt;By &lt;a href=&#34;https://twitter.com/hit1t&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Muhammet Ali A&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;&lt;a href=&#34;https://twitter.com/hit1t&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rıtürk&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this article, Muhammet takes us on a deep technical journey to persevere beyond the limitations of the proxy tool Burp Suite, and explore non-HTTP, application-layer protocols using ‘MITM RELAY’.&lt;/p&gt;
&lt;h1&gt;Introduction&lt;/h1&gt;&lt;p&gt;As an offensive security tester, we often rely on Burp Suite. While an excellent resource when penetration testing, it’s not without limitations, as we explored in our previous article on &lt;a href=&#34;https://labs.jumpsec.com/burp-suite-python-scripter/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;utilising custom python scripts.&lt;/strong&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;To get around some particular limitations in a recent case, I used a cool tool called &lt;a href=&#34;https://github.com/jrmdev/mitm_relay&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;MITM_RELAY&lt;/strong&gt;&lt;/a&gt; which is described as a “hackish way to intercept and modify non-HTTP protocols through Burp &amp;amp; others”. &lt;/p&gt;
&lt;p&gt;This tool allows us to compensate for Burp Suite’s limitations and extend it’s proxying capabilities for protocols beyond HTTP. Let’s explore why this is important when looking to secure an application. &lt;/p&gt;
&lt;h1&gt;Simulating a man-in-the-middle&lt;/h1&gt;&lt;p&gt;Imagine &lt;strong&gt;a mobile application&lt;/strong&gt;. We’ll call it &lt;strong&gt;Alpaca App.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/alpaca_app.png&#34; alt=&#34;alpaca app&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It has loads of great features that keep you connected with your favourite Alpaca friends. Besides being cool, the mobile app needs to be &lt;strong&gt;secure&lt;/strong&gt; when you’re using it to access the big bad internet. &lt;/p&gt;
&lt;p&gt;Our task in this article is to understand if the app is broadcasting and transferring data securely or insecurely enough for an adversary to &lt;strong&gt;intercept&lt;/strong&gt; the traffic. This can also be understood as &lt;strong&gt;man-in-the-middle&lt;/strong&gt; (MITM) attack, whereby a malicious (and nosy) actor eavesdrops on the network traffic that a machine is innocently transmitting and steals or manipulates the data for their evil purposes. &lt;/p&gt;
&lt;p&gt;An important tool for MITM research involves &lt;strong&gt;proxying&lt;/strong&gt;, which acts as an intermediate between two machines - and can be weaponized for evil purposes. &lt;a href=&#34;https://portswigger.net/burp/documentation/desktop/tools/proxy/getting-started&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Burp Suite&lt;/strong&gt;&lt;/a&gt; is a staple tool for studying web app and mobile app communications, as it proxies the information between the client and server so we can research exactly how the application works.&lt;/p&gt;
&lt;p&gt;Definitions aside, let’s talk about the technical complications for proxying our specific mobile app. Take a big old sip of coffee, and let&amp;rsquo;s get to work.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/coffee.png&#34; alt=&#34;coffee&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h1&gt;The limits of Burp Suite&lt;/h1&gt;&lt;p&gt;Burp Suite is able to catch &lt;strong&gt;HTTP&lt;/strong&gt; &lt;strong&gt;communications.&lt;/strong&gt; This is a specific application-layer protocol. The diagram below shows the process by which Burp Suite proxies communications over HTTP protocol. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/burp.png&#34; alt=&#34;burp&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;However, Burp Suite is &lt;strong&gt;ONLY&lt;/strong&gt; able to proxy this specific protocol. &lt;strong&gt;Unfortunately, Alpaca App doesn’t use HTTP to communicate. It uses XMPP instead.&lt;/strong&gt; So what now? &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Extensible Messaging and Presence Protocol (XMPP for short) is another application-layer protocol that is some decades old now, and originally went by the name &lt;strong&gt;Jabber.&lt;/strong&gt; &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Thankfully, we can use our new tool to intercept anything we want.&lt;/strong&gt; &lt;/p&gt;
&lt;h1&gt;Proxying XMPP traffic using MITM Relay&lt;/h1&gt;&lt;p&gt;As mentioned earlier, we are trying to understand whether &lt;strong&gt;Alpaca App is communicating securely.&lt;/strong&gt; Because it communicates via XMPP, we need to intercept that traffic and then study it. Let’s explain that again through a diagram: &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/xmpp.png&#34; alt=&#34;xmpp&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Not bad. So now we have a limited tool (Burp Suite) and we have a tool that can upgrade it (MITM_RELAY), so let’s get to work combining this so Burp Suite can understand Alpaca App’s XMPP!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Burp Suite has &lt;a href=&#34;https://portswigger.net/burp/documentation/desktop/tools/extender&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;its own extension&lt;/strong&gt;&lt;/a&gt; for &lt;a href=&#34;https://portswigger.net/bappstore/1d0986521ace4b2dbf0b70836efa999d&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;XMPP protocol interception&lt;/strong&gt;&lt;/a&gt;, but I didn’t find this to be as effective as the MITM_RELAY tool. &lt;/p&gt;
&lt;p&gt;The Burp XMPP extension would occasionally drop packets, which is obviously not ideal when trying to build a robust picture of the security of the app. The Burp extension, while having some good features, needed quite a bit of tinkering to make it work. &lt;/p&gt;
&lt;p&gt;In contrast, I found the MITM_RELAY tool easier to use, but really, you can use anything that you feel comfortable with!&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The &lt;a href=&#34;https://github.com/jrmdev/mitm_relay&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;creators&lt;/strong&gt;&lt;/a&gt; of the tool made a nice diagram below about how the tool works, and how to intercept different types of traffic via HTTP (Burp Suite) Proxy.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/mitm.png&#34; alt=&#34;mitm&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Digging deeper, the relay server has &lt;strong&gt;three&lt;/strong&gt; &lt;strong&gt;key&lt;/strong&gt; functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Relay Listener&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;listener&lt;/strong&gt; for a specific protocol and a specific source port will &lt;strong&gt;forward&lt;/strong&gt; the traffic to our &lt;strong&gt;target IP and target PORT&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Packet Wrapper and Unwrapper&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;This component will wrap all traffic into HTTP form and deliver it to the proxy tool. When the proxy tool forwards the traffic on, it will unwrap the traffic to it’s original protocol)&lt;/li&gt;
&lt;li&gt;So XMPP &amp;mdash;&amp;raquo; HTTP &amp;mdash;&amp;raquo; XMPP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Echo Web Server&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;This web server is a required part of this. As we’re sending the request over out proxy tool there will need to be a response after we finish sending the request&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;images/1.png&#34; alt=&#34;1&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Let’s go through this step by step. Assume our first XMPP packet has left &lt;strong&gt;Alpaca App,&lt;/strong&gt; and was intending to reach &lt;strong&gt;Alpaca Inc.’s servers&lt;/strong&gt; out in the big internet. &lt;/p&gt;
&lt;p&gt;1. It will pass through our relay server, be wrapped in HTTP, and sent to the Proxy server (Burp Suite)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2.png&#34; alt=&#34;2&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;2. After completing the wrapping-modification of the initial request, we will send it to the &lt;strong&gt;Echo Web server.&lt;/strong&gt; This will forward it to the upper level to unwrap it to the original protocol (XMPP) readying it to send to the Alpaca Inc. Server as originally intended:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/3.png&#34; alt=&#34;3&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;3. So far we have managed to successfully send Alpaca App’s XMPP traffic to the Alpaca Inc. server, situated on the internet. It is now the Alpaca Inc. server’s turn to answer us. Lets see how that works in return:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/4.png&#34; alt=&#34;4&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The application server then answers in the Alpaca app. We now have the ability to modify our requests to change the information we receive. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/5.png&#34; alt=&#34;5&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;4. When we are done examining Alpaca Inc.’s server response, we will let the XMPP packet go back to the client-side, (the Alpaca App). The same wrapping, unwrapping, and echo repeating occurs here to deliver the traffic back. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/6.png&#34; alt=&#34;6&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So far, so good? Are you doing alright? Here’s an alpaca meme to lighten things up.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/bags.png&#34; alt=&#34;bags&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We have followed the process from the first XMPP traffic from Alpaca App on our mobile phone, through our Burp Suite-MITM_RELAY that wraps it up in HTTP, and then when it unwraps it back to XMPP and gives it the Alpaca Inc. Server - and then back again through this whole apparatus.&lt;/p&gt;
&lt;p&gt;I hope you enjoyed the visuals, and they provided some benefit. &lt;strong&gt;Let’s open up the command-line, so you can replicate this and set this up too!&lt;/strong&gt;&lt;/p&gt;
&lt;h1&gt;Getting hands-on!&lt;/h1&gt;&lt;p&gt;Are you ready to do this yourself? You’ll need:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/jrmdev/mitm_relay&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MITM_RELAY script&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A proxy tool&lt;/strong&gt; (Burp, in our case)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Two mobile clients:&lt;/strong&gt; talking to each other using an the app’s XMPP protocol, &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A firewall rule:&lt;/strong&gt; needed to route the traffic from mobile client to relay server.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Setting up the environment&lt;span class=&#34;absolute -mt-20&#34; id=&#34;setting-up-the-environment&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#setting-up-the-environment&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;MITM_RELAY&lt;span class=&#34;absolute -mt-20&#34; id=&#34;mitm_relay&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#mitm_relay&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;For our MITM_RELAY setup, let&amp;rsquo;s look at the parameters we need:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/params-1-1024x114.png&#34; alt=&#34;params 1&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;:  Relaying settings. This parameter helps us to configure the relay
&lt;ul&gt;
&lt;li&gt;[local port] : [dest_host] : [dest_port]&lt;/li&gt;
&lt;li&gt;Or adding protocol: [udp:|tcp:] lport: rhost : rport&lt;/li&gt;
&lt;li&gt;Example: tcp:8083:142.250.187.238:443 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt; &lt;strong&gt;:&lt;/strong&gt; Relay listener. This is the address the relays will listen on. 
&lt;ul&gt;
&lt;li&gt;Be careful when setting this address, your relay listening address must be reachable from the client of you.&lt;/li&gt;
&lt;li&gt;And must be the same in  &amp;ndash;to&amp;ndash;destination  in iptables rule you use&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;&lt;strong&gt;:&lt;/strong&gt; The proxy parameter, in this case our proxy server will be in place&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Our MITM relay is now ready&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/mitmready.png&#34; alt=&#34;mitmready&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;Proxy Setup&lt;span class=&#34;absolute -mt-20&#34; id=&#34;proxy-setup&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#proxy-setup&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;We then can set up the rest of our proxy tooling and client-side Alpaca mobile app communication. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Our proxy tool (Burp Suite) is listening on &lt;strong&gt;192.168.1.184:8083&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;I am using a XMPP based chat mobile application. You, however, can choose any kind of application you would like to test. &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Firewall Setup&lt;span class=&#34;absolute -mt-20&#34; id=&#34;firewall-setup&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#firewall-setup&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;We will need to manipulate the firewall for our task. Fortunately for us, my colleague SHD already talks about how to use &lt;a href=&#34;https://labs.jumpsec.com/obfuscating-c2-during-a-red-team-engagement/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;iptables&lt;/strong&gt;&lt;/a&gt; to create super specific firewall changes.&lt;/p&gt;
&lt;p&gt;Lets leverage a visual to show what we’ll need our firewall to do: &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/firewall.png&#34; alt=&#34;firewall&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Our firewall will need to do some very specific port forwarding…there are two ways to utilise &lt;strong&gt;iptables&lt;/strong&gt; to achieve this task.&lt;/p&gt;
&lt;p&gt;You can either forward one specific port on TCP/UDP for all destinations to the relay: &lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;iptables -t nat -A OUTPUT -p tcp --dport &lt;span class=&#34;m&#34;&gt;5222&lt;/span&gt; -j DNAT --to-destination 192.168.1.184:9876&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Or you can forward one specific port on TCP/UDP for one specific destination to the relay:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;iptables -t nat -A OUTPUT -p tcp -s DEST_IP--dport &lt;span class=&#34;m&#34;&gt;5222&lt;/span&gt; -j DNAT --to-destination 192.168.1.184:9876&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;For the application you are researching, you have the task of identifying which ports to use and forward to - I unfortunately do not have the answers for your application. But I do have the answers for the Alpaca App, so let’s keep going. &lt;/p&gt;
&lt;h2&gt;Ready to start testing? &lt;span class=&#34;absolute -mt-20&#34; id=&#34;ready-to-start-testing&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#ready-to-start-testing&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Now that our environment is set up, let&amp;rsquo;s fire up our mobile application (Alpaca App) and see where the packets go.&lt;/p&gt;
&lt;h3&gt;Client to Server&lt;span class=&#34;absolute -mt-20&#34; id=&#34;client-to-server&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#client-to-server&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;In the top half of the screenshot (below), we can see MITM_RELAY confirm its listening configuration and then confirm it has received the new client (new connection)  that it will forward on. &lt;/p&gt;
&lt;p&gt;The lower half of the screenshot is our Burp Suite proxy tool that is receiving relay’s forwarded information.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/client_to_server.png&#34; alt=&#34;client to server&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;Server to Client&lt;span class=&#34;absolute -mt-20&#34; id=&#34;server-to-client&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#server-to-client&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;And on return from the Alpaca Inc. servers, Burp Suite intercepts the communication destined for the Alpaca mobile app.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;X-Mitm_Relay-to&lt;/strong&gt; and &lt;strong&gt;X-Mitm_Relay-From&lt;/strong&gt; indicates the changes between &lt;strong&gt;thick&lt;/strong&gt; &lt;strong&gt;client&lt;/strong&gt; and &lt;strong&gt;application&lt;/strong&gt; &lt;strong&gt;server&lt;/strong&gt; addresses dynamically, based on the where the packets come from.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/server_to_client.png&#34; alt=&#34;server to client&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;Alpaca App chat&lt;span class=&#34;absolute -mt-20&#34; id=&#34;alpaca-app-chat&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#alpaca-app-chat&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Let’s use the cool chat in the Alpaca App to send our best buddy a message.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/buddy.png&#34; alt=&#34;buddy&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This message goes from Alpaca App &amp;mdash;&amp;raquo; MITM_RELAY &amp;mdash;&amp;raquo; Burp Suite proxy. If we recall, this converts the original XMPP into HTTP, which Burp Suite can understand.&lt;/p&gt;
&lt;p&gt;We can see the intercepted contents in Burp Suite:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/intercepte.png&#34; alt=&#34;intercepte&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we have intercepted the message in the Alpaca App chat, we can drop or forward the message further. Let’s make sure it gets through.&lt;/p&gt;
&lt;p&gt;Here we can see the actual conversation between the two mobile devices. Both are using the Alpaca App and communicating through XMPP. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/comms.png&#34; alt=&#34;comms&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h1&gt;There and back again&lt;/h1&gt;&lt;p&gt;The moral of this story is that we do not have to give up on our security tooling if it has default limitations. On the contrary, we can layer up the tools we use and extend the capability of the tools that we are comfortable with. &lt;/p&gt;
&lt;p&gt;In our example, we extended Burp Suite’s HTTP-default capabilities with MITM_RELAY so we could assess the Alpaca App that uses the XMPP protocol. &lt;/p&gt;
&lt;p&gt;I hope you found this useful, and remember it next time you need to research TEXT-based traffic in Non-HTTP protocols. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Intercept everything and enjoy my friends!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/alpaca_cool.png&#34; alt=&#34;alpaca cool&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Muhammet Ali Arıtürk&lt;/strong&gt; is a Security Researcher @ JUMPSEC. &lt;/p&gt;
&lt;p&gt;You can &lt;a href=&#34;https://twitter.com/hit1t&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;follow him on Twitter&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Short introduction to Network Forensics and Indicators of Compromise (IoC)</title>
      <link>//localhost:1313/articles/2016/06/2016-06-28-short-introduction-network-forensics-indicators-compromise-ioc/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2016/06/2016-06-28-short-introduction-network-forensics-indicators-compromise-ioc/</guid>
      <description>
        
        
        &lt;p&gt;“&lt;em&gt;Indicator of compromise (IOC) in computer forensics is an artifact observed on a network or in an operating system that with high confidence indicates a computer intrusion. Typical IOCs are virus signatures and IP addresses, MD5 hashes of malware files or URLs or domain names of botnet command and control servers. After IOCs have been identified in a process of incident response and computer forensics, they can be used for early detection of future attack attempts using intrusion detection systems and antivirus software.&lt;/em&gt;” &lt;em&gt;Wikipedia&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Hello w0rld! In this post I am planning to do a brief introduction into network forensics and how network monitoring can be used to identify successful attacks. Network monitoring is essential in order to identify reconnaissance activities such as port scans but also for identifying successful attacks such as planted malware (such as ransomware) or spear-phishing. Generally when doing network forensics the network footprint is of significant importance since it allows us to replicate the timeline of events. With that said, network footprint can still be obscured/hidden by using cryptographic means such as point-2-point encryption. Even if you can’t see the actual traffic because it is encrypted, what you can see is the bandwidth load which might be an IoC.&lt;/p&gt;
&lt;p&gt;In incident response the first step is the time that is needed for the attack realization. If the attack is not realized then of course there is no ‘incident response’ (doh!). There is a list of things that the analyst should go over in order to try to identify if an attack was successful. The list is not definite and there are far more things that need to be checked than those discussed here. Whether an attack is targeted or non-targeted, if it is utilizing the Internet connection in any way it will leave network footprints behind. In targeted attacks we see things like spear-phishing and USB planting that quite often are targeting susceptible individuals with lack of security awareness. Non-targeted attacks might include attack vectors such as malware, ransomware, malicious javascripts, flash exploits, etc. This is not exhausting since flash exploits and malicious javascripts can be used also in a targeted fashion. By identifying the Indicators of Compromise (IoC), we can have briefly describe each attack vector as follows depending on the network footprint that will have:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP addresses&lt;/li&gt;
&lt;li&gt;domain names&lt;/li&gt;
&lt;li&gt;DNS resolve requests/response&lt;/li&gt;
&lt;li&gt;downloadable malicious content (javascripts, flash, PDF files with embedded scripts, DOCX with Macros enabled)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are also indicators coming out from behavioural analysis. For example a malware which contacts a Command &amp;amp; Control server will ‘beacon’ in a timely (usually) fashion. This ‘beaconing’ behaviour can be identified by monitoring spikes of specific traffic or bandwidth utilisation of a host. Moreover it can be spotted by monitoring out-of-hours behaviour since a host shouldn’t send data except of X type (which is legit) or shouldn’t be sending any data at all. Ransomware will encrypt all accessible filesystems/mounted drives and will ask (guess what!?) for money! Most likely it will be downloaded somehow or will be dropped by exploit kits or other malware. Sometimes it is delivered through email attachments (if mail administrator has no clue!). As stand-alone ‘version’ ransomware comes in portable executable (PE file) format. However variants of Cryptolocker are employing even PowerShell for doing so. In order to detect them we need a way to extract the files from the network dump. There are couple of tools that does this such as foremost but it is also possible to do it ‘manually’ through wireshark by exporting the objects. This assumes that the file transfer happened through an unencrypted channel and not under SSL. Malware might serve many different purposes such as stealing data, utilizing bandwidth for DDoS, or used as a ‘dropper’ where a ransomware is pushed. One of the more concerning is turning a compromised host into a zombie computer. Fast flux malware have numerous IPs associated with a single FQDN whereas domain flux malware have multiple FQDN per single IP. The latter is not ideal for malware authors since this IP will be easily identified and traffic will be dropped (a bit more about &amp;lsquo;&lt;em&gt;sinkhole&lt;/em&gt;&amp;rsquo; in the next paragraph!). Assuming that we are after a fast flux malware that uses a C&amp;amp;C, then there are ways to locate the malware by looking for beaconing. Quite often these malware make use of DGAs (Domain Generation Algorithms) which basically hide the C&amp;amp;C IP behind a series of different domain names. Malware that uses DGA are actively avoiding ‘sinkhole’ which allows ISPs to identify the malicious IP (C&amp;amp;C) and leading to the ‘blackhole’ of the traffic, shunning the communication of the infected system with it. An infected host will attempt to resolve (through DNS) a series of domain names acquired from the DGAs, This behaviour will lead to lots of ‘Non-Existent’ &lt;em&gt;NX&lt;/em&gt; responses from the name server back to the infected machine. Monitoring the number of &lt;em&gt;NX&lt;/em&gt; responses might help us identify infected systems. Moreover monitoring the DNS queries should also help.&lt;/p&gt;
&lt;p&gt;In a latter post I will publish a small script that I am using for looking for IoC.&lt;/p&gt;
&lt;p&gt;[caption id=&amp;ldquo;attachment_217&amp;rdquo; align=&amp;ldquo;aligncenter&amp;rdquo; width=&amp;ldquo;300&amp;rdquo;]&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2016/06/options.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/options-300x133.png&#34; alt=&#34;Main menu&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt; Script under development ;)[/caption]&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Research and Development</title>
      <link>//localhost:1313/articles/2016/01/2016-01-28-research-and-development/</link>
      <pubDate>Thu, 28 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2016/01/2016-01-28-research-and-development/</guid>
      <description>
        
        
        &lt;p&gt;Hello w0rld. On this post we would like to let you know our areas of research and the research projects that we are working on currently. For 2016 we are planning to develop tools that will be used in our tests. Our areas of interest can be highlighted as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AntiVirus Detection and Evasion techniques (sandbox detection, etc)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Packers, anti-debugging, anti-disassembly and binary obfuscation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Network packet capture analysis scripts looking for IoC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FUD Malware (maybe Veil Improvisation)&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The initial idea is to find a way to create several different templates on top of Veil. Additionally we can implement several add-ons for Virtual Machine detection or Sandbox Environment detection. This can be either logical-based such as human interaction or can be through technical means like red pills. Even 2-3 assembly instructions can be used for identifying a sandbox environment. Veil exports a .py file which is quite random. It randomizes variable names and also since it uses encryption it randomizes the key that will be used. Then it encrypts the payload and stores it in a .stub area on the binary. This area will be unfold after the execution and a routine is responsible for decrypting and launching the payload. This doesn’t offer and sandbox detection nor VM detection. It is heavily focused against AVs and specifically it is focused defeating signature-based detection systems. The idea of having different binaries but still using the same payload (meterpreter) is necessary for pentesters and for generating quickly payloads that will be used in social engineering tasks. Technically now the most important property is the large keyspace. The larger the key space the more ‘impossible’ to hit the same binary twice. Veil is providing that but still there are issues with the actual binary. My thought is to either break the exported binary and placed it under a new one OR just add several lines of code in the python script that will be used for compilation (through py2exe or pwninstaller). Another possibility is to mess around the pwninstaller and add things there. Another idea is to add randomisation on techniques defeating / escaping sandbox environments. Things that are looking promising:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mess with the actual PE Header, things like .STAB areas, add more stab areas add junk data to stab areas or even add other encrypted data that might look interesting (hyperion paper also has a super cool idea…)&lt;/li&gt;
&lt;li&gt;Change the file size of the exported binary dynamically. This will happen assuming the above will happen. (Can also be randomized with NOP padding&lt;/li&gt;
&lt;li&gt;Change values that will not necessarily mess the execution (maybe the versioning of the PE? or the Entry point of the binary?)&lt;/li&gt;
&lt;li&gt;Write a small scale packer for performance and maybe add also VM detection there&lt;/li&gt;
&lt;li&gt;Employ sandbox detection and VM detection through several means (this also adds to the 2nd step)&lt;/li&gt;
&lt;li&gt;Randomized routines for sandbox detection (if mouse_right_click = %random_value then decrypt else break/sleep)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Implementation techniques will include ctypes for sandbox detection and adding loops or other useless things such as calculations. Also using ndisasm or pyelf for messing the binary it is suggested. Red pills can be used in several different techniques.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Packer&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another idea that JUMPSEC labs have is to develop their own packer. This will have several routines for:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Static analysis obfuscation: Encryption&lt;/li&gt;
&lt;li&gt;Dynamic analysis obfuscation: Add noise in program flow/Add randomness to data/runtime&lt;/li&gt;
&lt;li&gt;Anti-debugging&lt;/li&gt;
&lt;li&gt;Sandbox escape: Detect human interactions&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Network Analysis Scripts&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We are developing several scripts for analysing pcap files. The purpose of these scripts is to parse packet captures and to identify whether there are IoC (Indicators of Compromise) by performing statistical analysis of the protocols usage and searching for potential protocol misuse (HTTP requests / responses that arent according to RFC).&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Covert channels - (Mis)Using ICMP protocol for file transfers with scapy</title>
      <link>//localhost:1313/articles/2015/04/2015-04-24-covert-channels-misusing-icmp-protocol-for-file-transfers-with-scapy/</link>
      <pubDate>Fri, 24 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2015/04/2015-04-24-covert-channels-misusing-icmp-protocol-for-file-transfers-with-scapy/</guid>
      <description>
        
        
        &lt;p&gt;Hello w0rld. In this post I will show how it is possible to (mis)use ICMP protocol for file transfers with scapy.&lt;/p&gt;
&lt;p&gt;“In computer security, a covert channel is a type of computer security attack that creates a capability to transfer information objects between processes that are not supposed to be allowed to communicate by the computer security policy.” &lt;em&gt;Source: &lt;a href=&#34;http://en.wikipedia.org/wiki/Covert_channel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wikipedia&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I have to give credit to the GhostInTheShellcode 2015 for “borrowing” the idea from the forensics challenge (see my previous post!). It is quite tricky to achieve, but the effort is worth it for the result. Network filtering restricts the traversal of specific packets or all the traffic of a kind. A firewall (pseudo)entry might be similar to “allow src dst http” “allow src dst icmp” and the (invisible usually) implicit deny restrict all other traffic. In cases like this there are 2 solutions; either use the existing “allow” for transferring data or switch to a different protocol which is allowed. ICMP is usually allowed because it was created for network troubleshooting mainly. More over messages like ICMP timestamps are blocked but echo requests/responses are not. A network admin that denies ICMP traffic will have troubleshooting difficulties when problems arise. The idea is not new, and according to the wish list of metasploit we should expect to see ICMP/UDP file transfers add-ons/functionalities to be introduced soon.&lt;/p&gt;
&lt;p&gt;My idea can be summarized as the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We have 2 ends, sender and receiver (else we can imagine it as attacker/compromised host)&lt;/li&gt;
&lt;li&gt;Attacker wants to send a file, let’s say an ELF or a PE file to the compromised host and for a reason he doesn’t want to use the solutions that exist already (meterpreter&amp;gt; upload function for example)&lt;/li&gt;
&lt;li&gt;ICMP is connectionless/ and not really stateful as TCP however it keeps track in a timed fashion (it can be considered stateful)&lt;/li&gt;
&lt;li&gt;I want to be able to parse a file and break it down to multiple chunks so that I can have different sizes of payloads&lt;/li&gt;
&lt;li&gt;Then I will send these chunks&lt;/li&gt;
&lt;li&gt;Client will receive these “pings” or more accurately this ICMP echo requests&lt;/li&gt;
&lt;li&gt;At the side of compromised host/receiver a file will be created and the payload of these requests will be appended.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For dealing with my ideas, I created 2 python scripts, a sender and a sniffer for grabbing the file. The sender is straightforward. The only thing that I had to add is the way of tearing down a file to multiple chunks and then parse these chunks for sending them. I used an &amp;ldquo;offset&amp;rdquo; so that in the future I can change the offset and have my chunks in different sizes. For the screenshot below you need to know that &lt;strong&gt;x=1&lt;/strong&gt; and &lt;strong&gt;y=2&lt;/strong&gt;. So the seek() will be executed just once for moving the file descriptor &amp;ldquo;offset&amp;rdquo; bytes ahead.&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2015/04/offset.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/offset.png&#34; alt=&#34;offset&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;Setting the offset for subsequent read&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;After the sender was done the &amp;ldquo;client&amp;rdquo; was the next step. I used the sniff() from scapy which I have to admit I didn&amp;rsquo;t really enjoy. There are several things that I learned out of this process most notable that the &lt;em&gt;count&lt;/em&gt; refers to the number of packets that will be received and NOT to the number of packets that will be received from the filter (packets that &amp;ldquo;hit&amp;rdquo; the filter!).&lt;/p&gt;
&lt;p&gt;Another issue that I had to solve was that I wanted specifically to grab the &lt;em&gt;Type 8&lt;/em&gt; &amp;ldquo;&lt;em&gt;echo request&lt;/em&gt;&amp;rdquo; messages. However when I was setting a &lt;em&gt;filter=icmp&lt;/em&gt; and then in my callback function an if statement as the following I was getting back duplicate packets.&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2015/04/sniff-issue1.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/sniff-issue1.png&#34; alt=&#34;sniff issue&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;This didnt work really&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Because of that I had to use a statement as &lt;em&gt;if raw in downloadlist&lt;/em&gt; so that I removed the double entries from my list.&lt;/p&gt;
&lt;p&gt;Another funny problem would arise in the case that another machine pings the receiver. In that case the payload of the echo request would be appended on the file. For this I just created an if statement and grab the packets coming from a specific source address.&lt;/p&gt;
&lt;p&gt;For testing our scripts in a &amp;ldquo;real case&amp;rdquo; scenario we placed the client on the host with IP 192.168.1.56 and the sender on 192.168.1.156. A simple ELF file was created.&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2015/04/elf-sent.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/elf-sent.png&#34; alt=&#34;elf sent&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;File used for transfer&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Then we launched the client and the sender and&amp;hellip;&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2015/04/sending-the-file.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/sending-the-file.png&#34; alt=&#34;sending the file&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;Sender. Sorry for the painful output of the non-printable chars :(&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2015/04/output_client_kappa.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/output_client_kappa.png&#34; alt=&#34;output_client_kappa&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;Client receiving the file and.. boom!&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;As you can imagine this PoC does not employ a way of obscuring what was sent. We can see that from what tcpdump spits&amp;hellip;&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2015/04/tcpdump_kappa.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/tcpdump_kappa.png&#34; alt=&#34;tcpdump_kappa&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;tcpdump clearly shows that some sort of an executable file that uses libc was transfered!&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;There are multiple limitations and challenges here.&lt;/p&gt;
&lt;p&gt;1st  The receiver/compromised host will reply back the payload that will be received; a behavior that is not good&lt;/p&gt;
&lt;p&gt;2nd ICMP does not have a “window-size” as TCP; there isn’t any “sliding window” that will allow us to send multiple chunks of a file in a single window. We need to take care of that somehow.&lt;/p&gt;
&lt;p&gt;3rd The ordering of data chunks is also a challenge. If the 2nd chunk arrives before the 1st one because of network-related issues (maybe a different route was chosen…) then the receiver/compromised host will reconstruct the file incorrectly&lt;/p&gt;
&lt;p&gt;4th Since scapy will be used (for now) we have all the limitations related to its capabilities (root access, installation dependencies, etc).&lt;/p&gt;
&lt;p&gt;In order to make it happen we need a small script to behave as a client and another one for the sender. The sender should also take care of the breaking up of the file to chunks of a specific size (must be less than the max_payload_size).&lt;/p&gt;
&lt;p&gt;Assuming that the ICMP type 8 messages are permitted then detection of a file transfer happening like that comes down to whether an IDS look for “abnormal” traffic. The type 8/0 messages depending on the OS (*nix/Windows/etc) have a similar payload every time that are getting sent (however it depends on the OS, Windows do not have the same payload with Linux). For finding the actual file though, a reconstruction of the file is necessary. Dealing with avoidance we have the following paths that we can use:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Encrypt the payload with a key hardcoded into client/server is obviously the strongest way. This would provide end to end encryption and from the network side it “shouldn’t” be possible to find what was sent.&lt;/li&gt;
&lt;li&gt;Encrypt the payload with a key that is sent through or a value of a packet. This is less “safe” when compared to method 1. But it is still difficult to reverse it. Even if you have the ciphertext and you can extract which algorithm was used you still need to know the key.&lt;/li&gt;
&lt;li&gt;Doing transposition/permutation. So imagine that we have an array with bytes where z = 0 and y = position of last element. By just reversing the order in the way transposed[y]=element[z] we can create a sequence that wouldn’t make sense at first place (Keep in mind that we do that per chunk (we can also do it per file but this leads to a smaller obfuscation)… so if we have a chunk size of 50 bytes and we are sending it on the reverse order if a file is big then it wouldn’t be so obvious what it is). This approach is (I guess) a way of performing steganography since we just hide the method that we use and we do not encrypt the actual payload. Still though there would be cases where an image header (or a trailer) sent on the reverse order would give away the fact that this is a header. For example the “.exe” if it is sent in that way it will look as “exe.” and would spoil our technique! Still though from a network forensics standpoint the analyst must find a way to find the start/end of the file and the correct sequences in order to reverse the process and reconstruct the file. There are multiple ways of performing this and only sky is the limit… So another example is to use a matrix x*y with the byte sequence of the payload and then shift the columns and the arrows around (similarly to AES process but without XORing) and then send the new matrix to the client who reverses the process.&lt;/li&gt;
&lt;li&gt;Use encoding instead. Still though encoding with base 64 can be easily spotted.&lt;/li&gt;
&lt;li&gt;Use a mixed approach of the the previous 2.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hiding the message though, doesn’t prove the fact that something sneaky happened. If an IPS monitors the ping requests and realizes that the payload is not the one that it should be then it can just discard the packets. There also firewalls that perform stateful inspection of ICMP.&lt;/p&gt;
&lt;p&gt;Covert channels are becoming more and more used. We have seen already steganography been used in videos, music but also in networking protocols. A malware author might use ICMP and/or UDP for dropping his downloader and the necessary protection mechanisms must be therefore deployed for mitigating that risk.&lt;/p&gt;
&lt;p&gt;Food for thought:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add also encryption to each chunk by hardcoding a key&lt;/li&gt;
&lt;li&gt;Porting it to C for making it a Portable Executable (PE-File)&lt;/li&gt;
&lt;li&gt;Writing it alternatively (still in python) with ctypes&lt;/li&gt;
&lt;li&gt;Add steganographic ways for obscurity&lt;/li&gt;
&lt;li&gt;Use other fields for the actual transfer of a file&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find the sender/client scripts in our github &lt;a href=&#34;https://bitbucket.org/jumpseclab/kit-kappa-icmp-transfer&#34; title=&#34;KIT download page&#34;target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;If you are still here, thanks for your time ;)&lt;/p&gt;
&lt;p&gt;Blooper Section!&lt;/p&gt;
&lt;p&gt;This happened while testing the sender with an offset=3!&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;a href=&#34;https://labs.jumpsec.com/wp-content/uploads/sites/2/2015/04/trolol.png&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;img src=&#34;images/trolol.png&#34; alt=&#34;trolol&#34; loading=&#34;lazy&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;Blooper: When computers decide not to speak human-languages&amp;hellip;&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

      </description>
    </item>
    
  </channel>
</rss>
