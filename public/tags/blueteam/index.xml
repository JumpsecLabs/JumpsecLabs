<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JUMPSEC – Blueteam</title>
    <link>//localhost:1313/tags/blueteam/</link>
    <description>Recent content in Blueteam on JUMPSEC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <lastBuildDate>Wed, 11 Aug 2021 00:00:00 +0000</lastBuildDate>
    
	  <atom:link href="//localhost:1313/tags/blueteam/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Running Once, &lt;del&gt;Running Twice&lt;/del&gt;, Pwned! Windows Registry Run Keys</title>
      <link>//localhost:1313/articles/2021/08/2021-08-11-running-once-running-twice-pwned-windows-registry-run-keys/</link>
      <pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2021/08/2021-08-11-running-once-running-twice-pwned-windows-registry-run-keys/</guid>
      <description>
        
        
        &lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://twitter.com/Purp1eW0lf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;By Dray Agha&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/Jumpsec_icons_Physical-security-2.png&#34; alt=&#34;Jumpsec icons Physical security 2&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The Windows registry is a vast and complex topic and cannot be understood and defended in one article. One particular area of interest from a security perspective is registry run keys. In this article, we discuss who uses run keys, how to uncover abuse, and how to eradicate evil from them. &lt;/p&gt;
&lt;h2&gt;An Introduction to Run Keys&lt;span class=&#34;absolute -mt-20&#34; id=&#34;an-introduction-to-run-keys&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#an-introduction-to-run-keys&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;What are registry run keys?&lt;/em&gt;&lt;/strong&gt; Run keys are an obscure mechanism of the registry to execute something on a Windows system when a user logs in or the machine boots up. &lt;/p&gt;
&lt;p&gt;A number of advanced adversaries have abused run keys due to their problematic nature. For example, &lt;a href=&#34;https://securelist.com/sofacy-apt-hits-high-profile-targets-with-updated-toolset/72924/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Fancy Bear&lt;/strong&gt;&lt;/a&gt; (also known as &lt;a href=&#34;https://download.bitdefender.com/resources/media/materials/white-papers/en/Bitdefender_In-depth_analysis_of_APT28%E2%80%93The_Political_Cyber-Espionage.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;APT28&lt;/strong&gt;&lt;/a&gt;), &lt;a href=&#34;https://www.proofpoint.com/us/blog/threat-insight/i-knew-you-were-trouble-ta456-targets-defense-contractor-alluring-social-media&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;TA456&lt;/strong&gt;&lt;/a&gt;, and &lt;a href=&#34;https://blog.talosintelligence.com/2018/01/korea-in-crosshairs.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Group 123&lt;/strong&gt;&lt;/a&gt; enjoy weaponizing run keys to achieve persistent access to a compromised network. Run keys have housed all manner of malicious content - from simple executables to macro-riddled spreadsheets.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MITRE ATT&amp;amp;CK® records this particular persistence tactic as the sub-technique &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/001/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;T1547.001&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;.&lt;/strong&gt; It is not a super common technique for adversarial campaigns, however it can offer ardent persistence - all the more reason for you and I to explore this obscurity further. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_16-53.png&#34; alt=&#34;2021 07 28 16 53&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Though advanced attackers abuse run keys on occasion, &lt;strong&gt;I find it is a mechanism that is not discussed widely enough, even though it is quite straightforward to query run keys for evil.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;The silence on this registry capability isn’t from technical gaps across the infosec community. &lt;strong&gt;Rather, run keys are an unexpected executable component of the ‘config database’ that is the Windows registry.&lt;/strong&gt; This means they often don’t get the same level of attention compared to bigger, more well-known attacker techniques and OS components. However, I recently came across this interesting snippet on the infosec social circuit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-08-02_17-15.png&#34; alt=&#34;2021 08 02 17 15&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Before we get into how to hunt for malicious run keys, &lt;strong&gt;let’s detour down the Windows registry.&lt;/strong&gt; &lt;/p&gt;
&lt;h2&gt;The Windows Registry&lt;span class=&#34;absolute -mt-20&#34; id=&#34;the-windows-registry&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-windows-registry&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The Windows registry is a labyrinthine place. On the surface it presents itself as a &lt;a href=&#34;https://docs.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;centralised database&lt;/strong&gt;&lt;/a&gt; to store information pertaining to user and machine settings. &lt;strong&gt;The reality is that it’s more a menagerie of weird and wonderful capabilities&lt;/strong&gt; that Microsoft sometimes obscurely document, despite these capabilities possessing devastating potential.&lt;/p&gt;
&lt;p&gt;I could spend hours writing about the inconsistencies and capriciousness of the Windows registry. Trying to understand the limits and parameters of its potential is truly maddening. It seems like the byzantine &lt;strong&gt;nature of the registry offers an adversary an unfair advantage&lt;/strong&gt; to stash away their persistence mechanisms and skulk outside the network until the Blue Team has averted their gaze. &lt;/p&gt;
&lt;p&gt;Trying to decipher what is benign and what is malevolent in the windows registry can be considered Sisyphean, especially during an incident.&lt;/p&gt;
&lt;h2&gt;Run keys&lt;span class=&#34;absolute -mt-20&#34; id=&#34;run-keys&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#run-keys&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;I hope so far I have conveyed just how difficult it is to tame the registry. To make matters worse, run key capabilities are criminally under-documented by Microsoft, who &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/setupapi/run-and-runonce-registry-keys&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;devote a mere six paragraphs&lt;/strong&gt;&lt;/a&gt; to them.&lt;/p&gt;
&lt;p&gt;Run keys live in the registry. They are configurable to allow a program to execute when a user logs in or the computer is turned on.  “&lt;em&gt;But hold on!&lt;/em&gt;”, I hear you angrily cry, “&lt;em&gt;Windows already has a&lt;/em&gt; &lt;strong&gt;&lt;em&gt;Task Scheduler&lt;/em&gt;&lt;/strong&gt;, &lt;em&gt;THAT’S how you schedule tasks!!!&lt;/em&gt;”&lt;/p&gt;
&lt;p&gt;Well, not according to our Lord and Saviour Bill Gates. Moreover, run keys have some crucial differences that make comparisons to Windows’ &lt;a href=&#34;https://docs.microsoft.com/en-us/windows/win32/taskschd/task-scheduler-start-page&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Task Scheduler&lt;/strong&gt;&lt;/a&gt; somewhat limited.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/memes-1.png&#34; alt=&#34;memes 1&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In contrast to Windows Task Scheduler, &lt;strong&gt;registry run keys possess a number of unique characteristics&lt;/strong&gt;:&lt;/p&gt;
&lt;h3&gt;Character Limitations&lt;span class=&#34;absolute -mt-20&#34; id=&#34;character-limitations&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#character-limitations&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Run keys can only store commands that are less than 280 characters.&lt;/strong&gt; So an adversaries’ one-liner must form as few characters as a Tweet. I hope Microsoft didn’t intend for THAT to be a low-tier defence mechanism, as your basic script-kiddie reverse shell will barely cost you 50 characters. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_15-43.png&#34; alt=&#34;2021 07 28 15 43&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Moreover, compiling your own malicious executable and firing it off via the run keys will cost you very few characters but achieve maximum effect. So whilst the character limitation is unique compared to other system timers, it’s a trivial obstacle. &lt;/p&gt;
&lt;h3&gt;Special Character Behaviour&lt;span class=&#34;absolute -mt-20&#34; id=&#34;special-character-behaviour&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#special-character-behaviour&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Another unique feature of run key considers how special characters change the behaviour of the scheduled command.&lt;/strong&gt; Specifically, the &lt;strong&gt;exclamation mark&lt;/strong&gt;  ( ! ) and the &lt;strong&gt;asterisk /&lt;/strong&gt; &lt;strong&gt;wildcard&lt;/strong&gt; ( * ). By default, the run key wipes itself after execution - whether it fails to execute its task or not. These two special characters can be deployed to alter this behaviour.&lt;/p&gt;
&lt;p&gt;If, on your next threat hunting session or incident response, you see this bad boy right here with an exclamation mark, you have encountered a run key that will persist until it has run its allocated command for sure. &lt;strong&gt;If for whatever reason the evil command does not run, the exclamation mark ensures that it will not delete itself until it runs successfully.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_09-24.png&#34; alt=&#34;2021 07 28 09 24&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The prefixed exclamation of a run key can be defeated by booting the computer in Safe Mode.&lt;/strong&gt; To ensure that a run key is executed regardless of boot mode, &lt;strong&gt;an adversary can leverage an asterisk / wildcard which forces the command to run.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_09-26.png&#34; alt=&#34;2021 07 28 09 26&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Run keys are configured to wipe themselves after running, by default, which means that unless your logging and detection is sharp, these kinds of malicious activities could go by unnoticed, unless you go through the painstaking  process of forensically recovering the image of the machine&lt;/p&gt;
&lt;h1&gt;Hunting Run Keys&lt;/h1&gt;&lt;p&gt;&lt;img src=&#34;images/2021-07-28_16-11.png&#34; alt=&#34;2021 07 28 16 11&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Is this your face right now? This was my face when I first encountered run keys. This may actually be my face all the time, to be honest. &lt;em&gt;#blueteamproblems&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Although run keys may seem complicated and obscure, &lt;strong&gt;I promise you they are anything but.&lt;/strong&gt; They are wonderfully easy to query and monitor, and they show up fabulously in a SIEM when an adversary manipulates their values. &lt;strong&gt;Let’s prove it together.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Finding Run Keys&lt;span class=&#34;absolute -mt-20&#34; id=&#34;finding-run-keys&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#finding-run-keys&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;There are a number of places where malicious run keys can be deployed. We’re just going to focus on the top four locations, but if you read some &lt;a href=&#34;https://dmcxblue.gitbook.io/red-team-notes/persistence/registry-keys-startup-folder&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;red team documentation&lt;/strong&gt;&lt;/a&gt; you’ll find some more registry locations to deploy run key persistence. &lt;/p&gt;
&lt;p&gt;Anyway, in the Windows registry, if you look under HKey Local Machine and Current User, and traverse a couple of directories, you’ll find &lt;strong&gt;Run&lt;/strong&gt; and &lt;strong&gt;RunOnce.&lt;/strong&gt; &lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\Run&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HKCU:\Software\Microsoft\Windows\CurrentVersion\Run&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;The directories are important here.&lt;/strong&gt; The behaviour of the run key is contingent on the registry location it is written in: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you see something written in &lt;strong&gt;HKLM:\&lt;/strong&gt; it means this was written as a &lt;strong&gt;high-privileged&lt;/strong&gt; user (most likely Admin) or SYSTEM.
&lt;ul&gt;
&lt;li&gt;Run keys written here can &lt;strong&gt;execute when the machine boots up&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If you see something something written in &lt;strong&gt;HKCU:\&lt;/strong&gt; it means this was written as just a &lt;strong&gt;normal user&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Run keys written here will &lt;strong&gt;only execute when the user logs in&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If you see something written to &lt;strong&gt;\RunOnce&lt;/strong&gt; it &lt;strong&gt;will&lt;/strong&gt; be removed after execution&lt;/li&gt;
&lt;li&gt;If you see something written in &lt;strong&gt;\Run&lt;/strong&gt; it &lt;strong&gt;will not&lt;/strong&gt; be removed after execution
&lt;ul&gt;
&lt;li&gt;These can be complicated by the &lt;strong&gt;special character behaviour&lt;/strong&gt; that we already discussed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What do Run Keys look like IRL ?&lt;span class=&#34;absolute -mt-20&#34; id=&#34;what-do-run-keys-look-like-irl-&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#what-do-run-keys-look-like-irl-&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;In real life, you actually have to sift a little bit of the registry’s noise to get to the meat of a run key.&lt;/strong&gt; Allow me to share with you two examples, where the first has not been filtered with PowerShell, and the second is enjoying a luxurious yet temporal life as filtered PowerShell.&lt;/p&gt;
&lt;p&gt;Look at this mess. What even is this? &lt;strong&gt;We don’t even need the stuff highlighted in the red box, it’s just noise.&lt;/strong&gt; We know this is the ‘HKLM’ Drive and ‘Run’ ChildName…&amp;hellip;we know that because we are the ones who traversed here! Honestly…&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_17-20-1024x349.png&#34; alt=&#34;2021 07 28 17 20&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Let’s filter out the noise with some PowerShell:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;Get-ItemProperty&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\Run&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;select &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;-property&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-exclude&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fl&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;images/124326535-76c64680-db7e-11eb-9b98-261b3704d30a.png&#34; alt=&#34;124326535 76c64680 db7e 11eb 9b98 261b3704d30a&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Look at how superior this is. Imagine running this glorious filtered-one-liner, and getting thousands of endpoints returning information in this kind of clear, noise-free way; the stuff Blue Team dreams are made of. &lt;strong&gt;This kind of filtered PowerShell is fantastically suited to be run enterprise-wide to identify anomalies beyond the standard builds across your network.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;If you look in the run keys, you&amp;rsquo;ll find the entries’ name and accompanying commands &lt;em&gt;(name: command).&lt;/em&gt; The legitimate contents of the run keys can vary and it’s your task to understand what is normal in your enterprise, as this will allow abnormal inconsistencies to stand out. &lt;/p&gt;
&lt;p&gt;As you hunt, you may want to filter out legitimate startup items in the registry runkeys. This is easily done. Using the same PowerShell as above, we can use the `-exclude` flag which already removes `PS*`. Just add a comma, and remove the other run key names that you don’t want to see. &lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;Get-ItemProperty&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\Run&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;select &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;-property&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-exclude&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vmware&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bginfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fl&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-08-03_16-21.png&#34; alt=&#34;2021 08 03 16 21&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Malicious Run Keys&lt;span class=&#34;absolute -mt-20&#34; id=&#34;malicious-run-keys&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#malicious-run-keys&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Let us emulate some of the adversaries&amp;rsquo; behaviour. We will insert some malice onto a run key, and then I will show you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;First,&lt;/strong&gt; how to loop through and find it automatically;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Second,&lt;/strong&gt; how you eradicate it from the machine without damaging the other legitimate run keys.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pretend we have pwned a machine, and are looking to maintain persistence. We compile evilcommand.exe, which bypasses all anti-virus known to man and gives us a reverse shell. &lt;strong&gt;We can force one of the run keys to execute our malicious program&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;Set-ItemProperty&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce&amp;#34;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Name&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;!Delete After Running&amp;#39;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Value&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;evilcommand.exe&amp;#34;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;If you append `-whatif` to the end of a lot of powershell one-liners, it will not actually run your command. Instead, it will show you what the effect COULD be if you ran it. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_09-04-1024x110.png&#34; alt=&#34;2021 07 28 09 04&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When you want to really run something, tag on `-verbose` so you can get confirmation that the PowerShell you expected has taken effect.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_09-06-1024x128.png&#34; alt=&#34;2021 07 28 09 06&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Without all of the noise, this is what we have forcibly co-opted the run key to do for us: we have created a run key named “&lt;strong&gt;Delete_After_Running&lt;/strong&gt;”, whose execution &lt;strong&gt;value&lt;/strong&gt; will be “&lt;strong&gt;evilcommand.exe&lt;/strong&gt;”. Notice the &lt;strong&gt;exclamation point&lt;/strong&gt;, which as we have discussed will ensure the program will run before it self-deletes, guaranteeing our successful re-entry to this compromised machine.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_09-11-1024x142.png&#34; alt=&#34;2021 07 28 09 11&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Task Scheduler is oblivious to this&lt;/strong&gt;. It does not and cannot recognise that this run key task has been scheduled. If I were Microsoft, I’d probably include that functionality in Task Scheduler…&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_15-36-1024x491.png&#34; alt=&#34;2021 07 28 15 36&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Finding Run Key evil&lt;span class=&#34;absolute -mt-20&#34; id=&#34;finding-run-key-evil&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#finding-run-key-evil&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;A quick Powershell ‘for loop’ can collect the contents of these four registry locations.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;When drafting this script, I (and now you, too) made life easier by ensuring the code produced output that was &lt;strong&gt;pre-filtered and added colours&lt;/strong&gt;. This will make our task that bit easier to determine &lt;strong&gt;IF&lt;/strong&gt; something &lt;strong&gt;abnormal&lt;/strong&gt; (read: evil) exists and &lt;strong&gt;WHERE&lt;/strong&gt; it exists.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;$items&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;vm&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\Run&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HKCU:\Software\Microsoft\Windows\CurrentVersion\Run&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;foreach&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$item&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$items&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;write-host&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;----Reg location is &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$item&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;----&amp;#34;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-ForegroundColor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Magenta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;get-itemproperty&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-path&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;$item&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;select &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;-property&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-exclude&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;fl
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_09-22.png&#34; alt=&#34;2021 07 28 09 22&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And if we look hard enough, &lt;strong&gt;we identify something abnormal&lt;/strong&gt;. Once we take the executable and reverse engineer it, we can determine it is a malicious executable from the adversary. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_17-42-1024x315.png&#34; alt=&#34;2021 07 28 17 42&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;If you identify a malicious run key, you are of course obliged to remove it from the machine. Let’s discuss how in a moment, &lt;strong&gt;after we discuss what this evil looks like from a SIEM / SOC perspective.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Monitoring for Evil&lt;span class=&#34;absolute -mt-20&#34; id=&#34;monitoring-for-evil&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#monitoring-for-evil&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Let’s discuss what this looks like from a detection and monitoring perspective.&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;For our example, we are using the built-in &lt;strong&gt;Windows Event Viewer&lt;/strong&gt;, and then adding &lt;a href=&#34;https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon#:~:text=System%20Monitor%20%5c%28Sysmon%5c%29%20is%20a,changes%20to%20file%20creation%20time.&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Sysmon&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/Neo23x0/sysmon-config&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Florian&lt;/strong&gt; &lt;strong&gt;Roth’s&lt;/strong&gt;&lt;/a&gt; config of rules for detection. You could then feed this sysmon log data into a SIEM, and monitor hundreds of thousands of endpoints for run key malice (and other stuff too).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_18-15.png&#34; alt=&#34;2021 07 28 18 15&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There is a wealth of information here worth considering: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The &lt;strong&gt;BLUE&lt;/strong&gt; arrows: event info&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;Event ID 13 involves registry values&lt;/strong&gt; &lt;strong&gt;modification&lt;/strong&gt;, and this ID will be consistent in any environment. &lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;EventType&lt;/strong&gt; and &lt;strong&gt;Task Category&lt;/strong&gt; spell out exactly what is happening here too: &lt;strong&gt;a registry value is being set&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;strong&gt;RED&lt;/strong&gt; arrows**:** specific info&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;TargetObject&lt;/strong&gt; shows the &lt;strong&gt;full path&lt;/strong&gt; for the run key registry we are changing. It also shows the &lt;strong&gt;name&lt;/strong&gt; we called it, and includes the special character that modifies the behaviour&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Details&lt;/strong&gt; section shows the command / executable the run key is forced to run&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;strong&gt;PINK&lt;/strong&gt; arrow: MITRE ATT&amp;amp;CK reference&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This may not be in every sysmon config. However &lt;strong&gt;Florian Roth&lt;/strong&gt; includes the MITRE ATT&amp;amp;CK tactic number in a particular event.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Rather than get attack alerts for every Event 13, I’d recommend you go on a bit of a discovery exercise of what the run keys in your environment normally do.&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;Across the entire enterprise do they have the same consistent contents? &lt;/p&gt;
&lt;p&gt;Or does the finance department run software that legitimately alters the run key? &lt;/p&gt;
&lt;p&gt;Would you be able to baseline this and then create a small alert for any new, inconsistent run key changes to a workstation in the finance department?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This has greater value than hoping to catch one rogue Event 13 out of a million.&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3&gt;Interactive detection&lt;span class=&#34;absolute -mt-20&#34; id=&#34;interactive-detection&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#interactive-detection&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;If you want a more interactive detection experience, might I recommend a tool like &lt;a href=&#34;https://docs.velociraptor.app/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Dr Michael Cohen’s Velociraptor?&lt;/strong&gt;&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Velocitaptor is a tool (and philosophy) that deserves its own article, so I will be brief here. Velociraptor is an endpoint response agent that you can install on every single endpoint across your enterprise, and orchestrate from one server via a web-app. This distributed tool allows us to then query thousands of machines at once. &lt;/p&gt;
&lt;p&gt;Built in to Velociraptor is a hunt that queries every Windows machine specifically for their startup process, and part of this hunt includes &lt;a href=&#34;https://github.com/Velocidex/velociraptor/blob/master/artifacts/definitions/Windows/Sys/StartupItems.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;querying run keys&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;.&lt;/strong&gt;  As you can see, this hunt targets a number of the registry run keys that our previous PowerShell query also hunted for. Velociraptor targets an additional few run keys, as well as some other startup locations (but I leave that to you to investigate this all further).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-08-02_10-30-1024x519.png&#34; alt=&#34;2021 08 02 10 30&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;If we fire off this startup detection hunt, we will be given a beautifully formatted table of results. In real production environments, you will find more noise than this so be warned! But look at what we detected - a single machine in our domain currently running &lt;strong&gt;C:\evil.exe&lt;/strong&gt;, shocking stuff. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-08-02_10-18-1024x665.png&#34; alt=&#34;2021 08 02 10 18&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Fortunately now we know and can eradicate it from the host - I’ll show you how.&lt;/strong&gt; &lt;/p&gt;
&lt;h2&gt;Eradicating Run Key Evil&lt;span class=&#34;absolute -mt-20&#34; id=&#34;eradicating-run-key-evil&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#eradicating-run-key-evil&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;It’s time. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/showtime.png&#34; alt=&#34;showtime&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Be surgical here.&lt;/strong&gt; If you aren’t precise in your commands, you will &lt;strong&gt;accidentally remove&lt;/strong&gt; run key entries that are &lt;strong&gt;legitimate&lt;/strong&gt;.  It&amp;rsquo;s important you remove with &lt;strong&gt;-verbose&lt;/strong&gt; too and double-check it has gone, to make sure you have removed what you think you have. &lt;/p&gt;
&lt;p&gt;Off the back of our PowerShell for loop, copy and paste the &lt;strong&gt;full path&lt;/strong&gt; location that the evil was detected. And double check this is where the malicious run key resides.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;Get-ItemProperty&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;select &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;-property&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-exclude&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fl&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_19-07-1024x276.png&#34; alt=&#34;2021 07 28 19 07&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Then pick the EXACT name of the run key entry you want to remove. Copy paste it, include any special characters too please. &lt;strong&gt;Don’t copy&lt;/strong&gt; the executable details that come &lt;strong&gt;after the colon&lt;/strong&gt; ( : )&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;Remove-ItemProperty&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Path&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce&amp;#34;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-Name&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;*Run Safe Mode too&amp;#34;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-verbose&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_19-11-1024x202.png&#34; alt=&#34;2021 07 28 19 11&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We get our verbose message returned to us confirming that we are indeed removing the run key we think we are.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-07-28_19-12-1024x127.png&#34; alt=&#34;2021 07 28 19 12&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Then check again to be sure it&amp;rsquo;s gone. If you still have the malicious run key here, double check you have copied and pasted appropriately, as fat-fingering paths and registry names are very real problems.&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-powershell&#34; data-lang=&#34;powershell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;Get-ItemProperty&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;select &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;-property&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;-exclude&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;*|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fl&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;images/empty-1024x124.png&#34; alt=&#34;empty&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h1&gt;Unpicking Run Keys&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Run keys are obscure mechanisms of persistence for sure. But I hope this article has instilled confidence in how straightforward it is to monitor, detect, control, and remove any malicious activity involving your run keys.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As a defender, sometimes our roles are framed as being consistently at a disadvantage compared to the adversary. They can leverage zero-days, they can trick users, they can run across time zones with bigger budgets. &lt;strong&gt;Whilst we must consistently be at the top of our game, they only need to be lucky once.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;All of this is true, but I find that sometimes we could invert this framing to focus on the advantages we possess compared to the attacker.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is &lt;strong&gt;OUR&lt;/strong&gt; environment. This is &lt;strong&gt;OUR&lt;/strong&gt; registry. And these are &lt;strong&gt;OUR&lt;/strong&gt; run keys. We know how it all works, and we should be here waiting for the adversary to so much as sneeze in our domain without us knowing about it. Sure, have a foothold. But we aren’t naive, we expect compromise. And we will catch you, kick you out, and ensure your future attempts at re-entry are that bit harder. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/sparta-1024x577.jpg&#34; alt=&#34;sparta&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Understand what is normal for your environment so you know when a registry run key manipulation is out of place, and foster a hostile network so an adversary can’t move an inch without you knowing about it and containing them.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There’s a lot to do and never enough time or resource to do it, but that’s why we’re in infosec right? &lt;/p&gt;
&lt;h2&gt;Some Bedside Reading&lt;span class=&#34;absolute -mt-20&#34; id=&#34;some-bedside-reading&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#some-bedside-reading&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;There are so many other janky registry entries that can do weird things with run keys. We didn’t mention, for example, how entire folders can become mechanisms of persistence via registry run keys! You can read more &lt;a href=&#34;https://www.picussecurity.com/resource/blog/picus-10-critical-mitre-attck-techniques-t1060-registry-run-keys-startup-folder&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&#34;https://dmcxblue.gitbook.io/red-team-notes/persistence/registry-keys-startup-folder&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;, and &lt;a href=&#34;https://attack.mitre.org/techniques/T1547/001/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you enjoyed this article or especially if you DIDN’T enjoy this article, give these other ones a go: looking at &lt;a href=&#34;https://labs.jumpsec.com/car-hacking-manual-bypass-of-modern-rolling-code-implementations/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;hacking cars&lt;/strong&gt;&lt;/a&gt; and breaking their keyfob encryption; evaluating the potential &lt;a href=&#34;https://labs.jumpsec.com/can-depix-deobfuscate-your-data/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;de-obfuscate redacted text&lt;/strong&gt;&lt;/a&gt; in sensitive documents; and advanced techniques to defend your &lt;a href=&#34;https://labs.jumpsec.com/obfuscating-c2-during-a-red-team-engagement/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;C2&amp;rsquo;s&lt;/strong&gt;&lt;/a&gt; honour.&lt;/p&gt;
&lt;p&gt;Any questions, comments, or criticisms please drop me a line&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://twitter.com/Purp1eW0lf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Twitter&lt;/a&gt; &lt;a href=&#34;https://github.com/Purp1eW0lf/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Github&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dray Agha,&lt;/strong&gt; Security Researcher&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2021-08-10_21-10.png&#34; alt=&#34;2021 08 10 21 10&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>A Defender’s Guide For Rootkit Detection: Episode 1 - Kernel Drivers</title>
      <link>//localhost:1313/articles/2020/04/2020-04-20-a-defenders-guide-for-rootkit-detection-episode-1-kernel-drivers/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/articles/2020/04/2020-04-20-a-defenders-guide-for-rootkit-detection-episode-1-kernel-drivers/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;Author: Thom (&lt;/em&gt;&lt;a href=&#34;https://twitter.com/rootkid8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;@rootkid8&lt;/em&gt;&lt;/a&gt;&lt;em&gt;), Sysmon Mastery Help from Rana (&lt;a href=&#34;https://twitter.com/sec_coffee&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@sec_coffee&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Introduction&lt;span class=&#34;absolute -mt-20&#34; id=&#34;introduction&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#introduction&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Even before my birth, rootkits have been one of the most sophisticated and successful ways of obtaining persistence on a machine, and now in 2020 there are ever more trivial ways of escalating from system to kernel. Recently JUMPSEC’s youngest red team researcher &lt;a href=&#34;https://twitter.com/_batsec_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@_batsec_&lt;/a&gt; &lt;a href=&#34;https://blog.dylan.codes/evading-sysmon-and-windows-event-logging/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;raised the bar once more using rootkit techniques to universally evade Sysmon&lt;/a&gt;. This method of defeating Event Tracing for Windows is an incredible feat and the world of Windows logging is left shaken. As a result, we’re going to go down the rabbit hole of kernel driver rootkits, specifically looking at the use of vulnerable kernel drivers to escalate to ring-zero. First we need to start with some basics, how the Windows kernel implements defence-in-depth, how to bypass these restrictions, and how network defenders and system administrators can detect these techniques as “trivially” as attackers can implement them (skip to the end for a Sysmon Config). &lt;/p&gt;
&lt;h2&gt;Some OS Basics&lt;span class=&#34;absolute -mt-20&#34; id=&#34;some-os-basics&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#some-os-basics&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;For those of us who don&amp;rsquo;t know, operating systems and common CPU&amp;rsquo;s define hierarchical protection domains to implement defense in depth. Code executing on the CPU is run in one of these rings using CPU modes - with ring 3 being user-land and ring 0 being kernel-land. &lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2020-04-16-090738_677x477_scrot.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Only certain applications that require access to low level devices and hardware should be allowed access to run code in rings 2, 1 and 0, which is enforced at a microcode level on the CPU as well as by the operating system. In theory this privilege domain is sound, and its introduction expelled the days of causing total system crashes with one line of buggy code in user-land. However, the implementation of these rings at the operating system level, and worse-so at the driver level is reasonably vague and undocumented, opening up an entire space for kernel driver exploits as post exploitation privilege escalation and persistence mechanisms. &lt;/p&gt;
&lt;h2&gt;Writing a Kernel Mode Driver&lt;span class=&#34;absolute -mt-20&#34; id=&#34;writing-a-kernel-mode-driver&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#writing-a-kernel-mode-driver&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;We’re going to look more closely at how Windows handles device drivers, since these drivers allow access to kernel space, we will hopefully uncover some of the ways to get arbitrary code to run in kernel mode without the use of a signed driver. Heck, &lt;a href=&#34;https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/writing-a-very-small-kmdf--driver&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;writing a kernel mode driver isn’t a particularly challenging task&lt;/a&gt;, but if you want it to run on a target system it will require setting up “Test Mode” on the operating system or completely disabling device driver signing enforcement (DSE) globally which requires access to the boot settings, or through running the following command followed by a reboot:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;bcdedit /set testsigning on&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Both of these techniques are about as stealthy as using a sledgehammer to hide the noise of your power drill, and not only will most ordinary users recognise the &lt;strong&gt;Test Mode&lt;/strong&gt; warning on their device, many organisations restrict this functionality group wide, &lt;a href=&#34;https://docs.microsoft.com/en-us/windows-hardware/drivers/install/the-testsigning-boot-configuration-option&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;and if they don’t then they really should.&lt;/a&gt; There is of course a way to hide the watermarks and warnings, but again this is a sledgehammer approach since bcdedit will be caught by a blue team with any real level of sophistication.&lt;/p&gt;
&lt;p&gt;Instead, we need to bypass Driver Signature Enforcement and PatchGuard, both of which being Windows kernel protection mechanisms. One to prevent unsigned drivers being loaded and another to prevent drivers from modifying critical kernel data structures through integrity checks. Again, any blue team should be able to detect the loading of a driver with an expired certificate - &lt;a href=&#34;https://github.com/SwiftOnSecurity/sysmon-config&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SwiftOnSecurity’s handy Sysmon config will anyway!&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;The Story of One Kernel Driver Loader&amp;hellip;&lt;span class=&#34;absolute -mt-20&#34; id=&#34;the-story-of-one-kernel-driver-loader&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-story-of-one-kernel-driver-loader&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;In order to explore these kernel mode drivers, we need to take a trip back in time. There used to be (and still are) some fantastic base projects for kernel mode drivers like the ones we’re investigating. Written by a legend in this space &lt;a href=&#34;https://twitter.com/hfiref0x?lang=en&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@hfiref0x&lt;/a&gt; - we’ll start with &lt;a href=&#34;https://github.com/hfiref0x/TDL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TDL or Turla Driver Loader&lt;/a&gt;. Around 4 years ago, this tool was a rootkit developer&amp;rsquo;s wet dream. It’s the supercedent to &lt;a href=&#34;https://github.com/hfiref0x/DSEFix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DSEFix&lt;/a&gt;, another driver loader written by hfiref0x, that became obsolete due to its modification of kernel variables that got blocked by PatchGuard rendering it a guaranteed blue screen generator - a fun prank but not what we’re looking for. &lt;/p&gt;
&lt;p&gt;TDL acts as a fully functional driver loader that can be used independently of the Windows loader. As a byproduct it defeats 64-bit driver signature enforcement as well. The magic of Turla is the offensive technique it uses to get a custom driver to load into kernel memory. It comes packaged with a vulnerable version of a VirtualBox kernel mode driver, it loads and exploits this driver to overwrite kernel memory with a custom crafted driver before jumping to the DriverEntry function to begin execution. Effectively this can be visualised as so:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/Rootkits.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This technique is somewhat akin to process hollowing, but instead of creating a suspended thread and mapping our code into it, we load a known driver and use shellcode to map our malicious code into that segment of memory.&lt;/p&gt;
&lt;p&gt;The technique is surprisingly simple, but extremely effective. Since the VirtualBox driver runs in kernel mode already, by dropping shellcode that now runs in kernel land we can execute an mmov, an mmap, and a jump (in reality it’s much more complex than that but just for simplicity’s sake we rely on those three instructions). This means that all the target kernel driver needs is permission to read and write physical memory, and have a code execution CVE for it to become a candidate for kernel driver loading.&lt;/p&gt;
&lt;p&gt;Clearly hfiref0x doesn’t sleep, and soon after TDL, &lt;a href=&#34;https://github.com/hfiref0x/Stryker&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stryker&lt;/a&gt; was released, yet another kernel driver loader. This time the loader was crafted to &lt;a href=&#34;https://www.cpuid.com/softwares/cpu-z.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;exploit a CPU-Z driver&lt;/a&gt; instead, functioning very similarly to its predecessor. Now again in 2020,  hfiref0x strikes again with the release of Kernel Driver Utility (&lt;a href=&#34;https://github.com/hfiref0x/KDU&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;KDU&lt;/a&gt;) just 2 months ago, the same concept is being used, except now KDU supports multiple vulnerable drivers as “functionality providers&amp;rsquo;&amp;rsquo;. Hilariously named, these functionality providers are the keys to the kingdom, and if we have any hopes of detecting rootkits that use this technique we need to understand how KDU loads these drivers, how it exploits them, and what breadcrumbs we can search for on systems to check for compromise.&lt;/p&gt;
&lt;p&gt;Looking briefly at the Github attributes we can see there are 4 CVE’s associated with the project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-2291&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cve-2015-2291&lt;/a&gt; &lt;a href=&#34;https://github.com/topics/cve-2019-18845&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;/a&gt;- IQVW32.sys intel ethernet driver vulnerability&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18845&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cve-2019-18845&lt;/a&gt; &lt;a href=&#34;https://github.com/topics/cve-2018-19320&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;/a&gt;- MsIo64.sys and MsIo32.sys Patriot Viper vulnerability&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nvd.nist.gov/vuln/detail/CVE-2018-19320&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cve-2018-19320&lt;/a&gt; &lt;a href=&#34;https://github.com/topics/cve-2019-16098&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;/a&gt;- GDrv graphics driver vulnerability &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-16098&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cve-2019-16098&lt;/a&gt; - RTCore64.sys and RTCore32.sys vulnerability&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With more providers mentioned in the README:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ATSZIO64 driver from ASUSTeK WinFlash utility of various versions;&lt;/li&gt;
&lt;li&gt;GLCKIO2 (WinIo) driver from ASRock Polychrome RGB of version 1.0.4;&lt;/li&gt;
&lt;li&gt;EneIo (WinIo) driver from G.SKILL Trident Z Lighting Control of version 1.00.08;&lt;/li&gt;
&lt;li&gt;WinRing0x64 driver from EVGA Precision X1 of version 1.0.2.0;&lt;/li&gt;
&lt;li&gt;EneTechIo (WinIo) driver from Thermaltake TOUGHRAM software of version 1.0.3.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The most notable thing regarding these vulnerabilities is that they all expose ring-zero code execution capabilities, enabling the entire kill-chain of KDU. Even more interestingly  CVE-2019-16098 even states in the description: &lt;strong&gt;&lt;em&gt;These signed drivers can also be used to bypass the Microsoft driver-signing policy to deploy malicious code.&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;As a disclaimer, we can note that hfiref0x states KDU and all similar tools are not actually hacking tools, they are for driver developers to make their lives easier. &lt;strong&gt;A lazy AV will flag this tool as malware&lt;/strong&gt;, but also because in many senses of the word, KDU is malware in the same way a remote access tool for sysadmins can be malware.&lt;/p&gt;
&lt;h2&gt;Static Analysis &lt;span class=&#34;absolute -mt-20&#34; id=&#34;static-analysis&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#static-analysis&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;[WARNING: RABBIT HOLE AHEAD]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If you’re not interested in KDU source code or boring operating system details then skip to Dynamic Analysis.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Examining the source code of KDU we see an abstraction layer that is implemented by the driver loader, each provider has the following structure:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;144 typedef struct _KDU_PROVIDER {                          
…………………………………………………
161     struct {
162         provRegisterDriver RegisterDriver; //optional
163         provUnregisterDriver UnregisterDriver; //optional
164
165         provAllocateKernelVM AllocateKernelVM; //optional
166         provFreeKernelVM FreeKernelVM; //optional
167
168         provReadKernelVM ReadKernelVM;
169         provWriteKernelVM WriteKernelVM;
170
171         provVirtualToPhysical VirtualToPhysical; //optional
172         provReadControlRegister ReadControlRegister; //optional
173     
174         provQueryPML4 QueryPML4Value; //optional
175         provReadPhysicalMemory ReadPhysicalMemory; //optional
176         provWritePhysicalMemory WritePhysicalMemory; //optional
177     } Callbacks;
178 } KDU_PROVIDER, * PKDU_PROVIDER;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I’ve ignored the unimportant fields, but from here we can understand what it takes to construct a provider, and we can see there are function pointers required for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reading and writing virtual memory, &lt;/li&gt;
&lt;li&gt;mapping virtual addresses to physical addresses, &lt;/li&gt;
&lt;li&gt;reading and writing physical addresses &lt;/li&gt;
&lt;li&gt;reading two kernel registers - the PML4 and the Control Register&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It should be pretty clear so far why we need to be able to read and write physical and virtual memory addresses, but what are the PML4 and the control register and why does the exploit require them? Well if you’re familiar with Linux kernels then the PML4 is simply the base address to the multi-level page table that the kernel uses to map linear virtual address spaces to processes. In order to replace our driver in memory we need to be able to find where it’s stored in memory which requires reading from the page table to find the address space of the target driver. Hence we can read this base address from the PML4 register. &lt;/p&gt;
&lt;p&gt;The control register should also be familiar to kernel developers or assembly folks, but to those of you who don’t know - it’s a 64-bit register that has a few important use cases required by virtual memory mapping and paging. In cases where either no function is defined for mapping virtual memory to physical memory, and nothing for reading the PML4, KDU uses the control register value to find the page directory address. This allows it to translate virtual addresses to physical addresses so it can walk through the page table and overwrite physical kernel memory regions:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt; 39  BOOL PwVirtualToPhysical(
 40     _In_ HANDLE DeviceHandle,
 41     _In_ provQueryPML4 QueryPML4Routine,
 42     _In_ provReadPhysicalMemory ReadPhysicalMemoryRoutine,
 43     _In_ ULONG_PTR VirtualAddress,
 44     _Out_ ULONG_PTR* PhysicalAddress)
 45 {   
 46     ULONG_PTR   pml4_cr3, selector, table, entry = 0;
 47     INT         r, shift;
 48     
 49     *PhysicalAddress = 0;
 50     
 51     if (QueryPML4Routine(DeviceHandle, &amp;amp;pml4_cr3) == 0)
 52         return 0;
 53     
 54     table = pml4_cr3 &amp;amp; PHY_ADDRESS_MASK;
 55     
 56     for (r = 0; r &amp;lt; 4; r&amp;#43;&amp;#43;) {
 57         
 58         shift = 39 - (r * 9);
 59         selector = (VirtualAddress &amp;gt;&amp;gt; shift) &amp;amp; 0x1ff;
 60         
 61         if (ReadPhysicalMemoryRoutine(DeviceHandle,
 62             table &amp;#43; selector * 8,
 63             &amp;amp;entry,
 64             sizeof(ULONG_PTR)) == 0)
 65         {   
 66             return 0;
 67         }
 68         
 69         if (PwEntryToPhyAddr(entry, &amp;amp;table) == 0)
 70             return 0;
 71         
 72         if ((r == 2) &amp;amp;&amp;amp; ((entry &amp;amp; ENTRY_PAGE_SIZE_BIT) != 0)) {
 73             table &amp;amp;= PHY_ADDRESS_MASK_2MB_PAGES;
 74             table &amp;#43;= VirtualAddress &amp;amp; VADDR_ADDRESS_MASK_2MB_PAGES;
 75             *PhysicalAddress = table;
 76             return 1;
 77         }
 78     }
 79     
 80     table &amp;#43;= VirtualAddress &amp;amp; VADDR_ADDRESS_MASK_4KB_PAGES;
 81     *PhysicalAddress = table;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Digging deeper into the source code we actually discover that there are two drivers at play here: a victim driver and a vulnerable driver. Initially I presumed these to be the same driver, but the code appears to unpack, load and start the vulnerable driver first - this is the &lt;em&gt;provider&lt;/em&gt; - after which it calls KDUMapDriver which tries to load the victim driver.&lt;/p&gt;
&lt;p&gt;In the case of KDU, the victim driver is always the process explorer &lt;strong&gt;PROCEXP152&lt;/strong&gt;.sys driver, it bootstraps shellcode into the IRP_MJ_DEVICE_CONTROL callback of PROCEXP152, before finally unloading it, triggering the shellcode to execute inside PROCEXP152, allowing the target driver to be loaded into kernel memory.&lt;/p&gt;
&lt;p&gt;Finally, let’s take a look at the core loader functionality, we want to understand the shellcode bootstrapping, and the system calls used to help us figure out what level of detection is possible. This snippet of code is where the bootstrapping happens inside KDUSetupShellCode:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;382         //
383         // Resolve import (ntoskrnl only) and write buffer to registry.
384         //
385         isz = FileHeader-&amp;gt;OptionalHeader.SizeOfImage;
386
387         DataBuffer = supHeapAlloc(isz);
388         if (DataBuffer) {
389             RtlCopyMemory(DataBuffer, Image, isz);
390
391             printf_s(&amp;#34;[&amp;#43;] Resolving kernel import for input driverrn&amp;#34;);
392             supResolveKernelImport((ULONG_PTR)DataBuffer, KernelImage, KernelBase);
393             
394             lResult = RegOpenKey(HKEY_LOCAL_MACHINE, NULL, &amp;amp;hKey);
395             if ((lResult == ERROR_SUCCESS) &amp;amp;&amp;amp; (hKey != NULL)) {
396
397                 lResult = RegSetKeyValue(hKey, NULL, TEXT(&amp;#34;~&amp;#34;), REG_BINARY,                                        
398                     DataBuffer, isz);
399
400                 bSuccess = (lResult == ERROR_SUCCESS);
401
402                 RegCloseKey(hKey);
403             }
404             supHeapFree(DataBuffer);
405         }
406     }&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;We see that first it finds the &lt;code&gt;**ntoskrnl**.exe&lt;/code&gt; base address - this is the starting address space of the kernel mapped memory region, containing important structures such as the page directory of mapped memory for all processes on the system. This is important because most process monitoring tools should be able to detect if this image is loaded. After this it calls &lt;code&gt;KDUStorePayload&lt;/code&gt; on the driver filename passed to it - interestingly this function writes a byte buffer that is just the raw bytes of the &lt;strong&gt;&lt;code&gt;rootkit.sys&lt;/code&gt;&lt;/strong&gt; &lt;em&gt;(or whatever input kernel mode driver you specify)&lt;/em&gt; to a registry hive in &lt;code&gt;HKLM&lt;/code&gt; with the key “~”:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;images/2020-04-15-115900_749x165_scrot.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;[&lt;code&gt;4d5a&lt;/code&gt; is hex for &lt;code&gt;MZ&lt;/code&gt; also known as the magic bytes in the header of a PE image.]&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A fun part of this registry write is that KDU doesn’t clean up after itself so this artifact remains on the system as an IOC even after KDU’s removal. I’ve thrown together a little powershell script that you can find in the appendix for incident responders to check whether any PE data has been written to registry keys. It will detect KDU in it’s default state as well as any basic attempts at KDU modifications that change the target hive, and any other tools that write executable data to the registry.&lt;/p&gt;
&lt;p&gt;Furthermore, we come across this function call inside &lt;code&gt;VictimBuildName&lt;/code&gt; in &lt;code&gt;**victim**.cpp&lt;/code&gt; that writes the victim driver &lt;strong&gt;&lt;code&gt;.sys&lt;/code&gt;&lt;/strong&gt; in the &lt;code&gt;%TEMP%&lt;/code&gt; directory:&lt;/p&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt; 61 LPWSTR VictimBuildName(
 62     _In_ LPWSTR VictimName
 63 )
 64 {
 65     LPWSTR FileName;
 66     SIZE_T Length = (1024 &amp;#43; _strlen(VictimName)) * sizeof(WCHAR);
 67
 68     FileName = (LPWSTR)supHeapAlloc(Length);
 69     if (FileName == NULL) {
 70         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
 71     }
 72     else {
 73
 74         DWORD cch = supExpandEnvironmentStrings(L&amp;#34;%temp%\&amp;#34;, FileName, MAX_PATH);
 75         if (cch == 0 || cch &amp;gt; MAX_PATH) {
 76             SetLastError(ERROR_NOT_ENOUGH_MEMORY);
 77             supHeapFree(FileName);
 78             FileName = NULL;
 79         }
 80         else {
 81             _strcat(FileName, VictimName);
 82             _strcat(FileName, L&amp;#34;.sys&amp;#34;);
 83         }
 84     }
 85
 86     return FileName;
 87 }&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This is exciting, as file writes are also solid ways of detecting malicious activity, especially if the write operations are hardcoded into the executable and not generated on the fly or randomly.&lt;/p&gt;
&lt;h2&gt;Dynamic Analysis&lt;span class=&#34;absolute -mt-20&#34; id=&#34;dynamic-analysis&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#dynamic-analysis&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Now that we have some potential indicators of execution for KDU from the source code: registry writes, files writes and image loads, we’re going to write some tests to see how this works in practice. To test these providers, I compiled KDU from source, wrote a custom kernel mode driver that acts as a tiny example rootkit, and wrote a batch script to execute &lt;strong&gt;&lt;code&gt;kdu -map -prv &amp;lt;ID&amp;gt; rootkit.sys&lt;/code&gt;&lt;/strong&gt; repeatedly with each of the providers in sequence. In each case we analyse the changes made to the system, in this example we’ll be using Procmon, and Sysmon.&lt;/p&gt;
&lt;p&gt;The procmon test shows a pretty clear pattern of events demonstrated by the following diagram:&lt;/p&gt;
&lt;figure&gt;
&lt;p&gt;&lt;img src=&#34;images/image-1024x409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;figcaption&gt;
&lt;p&gt;Sysmon output&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Using our custom Sysmon config, we also see the following events traced by Sysmon: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create %TEMP%&lt;strong&gt;PROVIDER&lt;/strong&gt;.sys &lt;/li&gt;
&lt;li&gt;Set HKLMSystemCurrentControlSetServices&lt;strong&gt;PROVIDER&lt;/strong&gt;Start registry value to 3 (Manual Start)&lt;/li&gt;
&lt;li&gt;Set HKLMSystemCurrentControlSetServices&lt;strong&gt;PROVIDER&lt;/strong&gt;ImagePath to %TEMP%&lt;strong&gt;PROVIDER&lt;/strong&gt;.sys&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DRIVER LOADED&lt;/em&gt;&lt;strong&gt;&lt;em&gt;: PROVIDER.sys&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Create %CD%&lt;strong&gt;PROCEXP152&lt;/strong&gt;.sys&lt;/li&gt;
&lt;li&gt;Set HKLMSystemCurrentControlSetServices&lt;strong&gt;PROCEXP152&lt;/strong&gt;Start registry value to 3 (Manual Start)&lt;/li&gt;
&lt;li&gt;Set HKLMSystemCurrentControlSetServices&lt;strong&gt;PROCEXP152&lt;/strong&gt;ImagePath to %CD%&lt;strong&gt;PROCEXP152&lt;/strong&gt;.sys&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DRIVER LOADED&lt;/em&gt;&lt;strong&gt;&lt;em&gt;: PROCEXP152.sys&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Unsigned Image loaded &lt;strong&gt;rootkit.sys&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This makes more sense if we understand that the registry values in &lt;strong&gt;HKLMSystemCurrentControlSetServices&lt;Driver&gt;&lt;/strong&gt; are set and unset when Windows services are loaded, and these actions aren’t actually performed by the KDU code directly. Instead these events can be read as:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Unpack vulnerable (provider) driver to &lt;code&gt;%CD%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start it&lt;/li&gt;
&lt;li&gt;Write rootkit binary data to &lt;code&gt;HKLM~&lt;/code&gt; registry hive&lt;/li&gt;
&lt;li&gt;Unpack victim driver (&lt;code&gt;**PROCEXP152**.sys&lt;/code&gt;) to &lt;code&gt;%TEMP%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start it&lt;/li&gt;
&lt;li&gt;Unsigned rootkit kernel driver loaded into kernel memory&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This is almost exactly the pattern evident from the source code, although we had to add an explicit rule to pick up the binary data in &lt;code&gt;HKLM~&lt;/code&gt;. What we can note here as well is that this entire process relies on the loading of a very particular version of a vulnerable driver - this means it’ll have a particular hash which we could also use as a signature, as well as the final event - an unsigned driver still gets loaded into memory is the biggest telltale sign of something suspicious happening.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;span class=&#34;absolute -mt-20&#34; id=&#34;conclusion&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#conclusion&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Now, &lt;a href=&#34;https://www.reddit.com/r/blueteamsec/comments/fychxz/detect_ghostinthelogs_when_executed_disables_all/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;obviously we could have just executed KDU right at the start of this and obtained the IOC’s instantly, but where’s the fun in that&lt;/a&gt;? Instead you should now understand one fairly general technique for elevating from system to kernel, the inner workings of kernel level driver loaders (and the many similar tools using this technique), as well as how we can detect them. &lt;/p&gt;
&lt;p&gt;These detection techniques aren’t particularly sophisticated however, and nothing prevents an adversary from patching or tweaking these variables so KDU writes to different registry hives or disk locations. Or worse yet, making it load the victim and vulnerable drivers from memory instead of dumping them to disk first, in which case we would only see the starting and stopping of the vulnerable and victim driver services. Then simply patching the vulnerable drivers with arbitrary null bytes before loading them would modify the hashes detected by Sysmon. Such is life in cybersecurity… In part 2 we’re going to look at some more sophisticated evasion techniques that rootkits use, and how we can detect those too, so stay tuned!&lt;/p&gt;
&lt;p&gt;The supporting work in this area is my only credit, people like &lt;a href=&#34;https://twitter.com/hFireF0X&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@hfiref0x&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/FuzzySec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@fuzzysec&lt;/a&gt;, and of course our dude &lt;a href=&#34;https://twitter.com/_batsec_&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@_batsec_&lt;/a&gt; constantly finding ways to break the Windows kernel and invalidate the integrity of our operating systems is one of the many wonders of this world. &lt;/p&gt;
&lt;h2&gt;Appendix&lt;span class=&#34;absolute -mt-20&#34; id=&#34;appendix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#appendix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Some sysmon rules for detecting KDU and similar tools (the DriverLoad and ImageLoad events may require you to update your exclusion filters) as the vulnerable drivers that get loaded often appear legitimate and are even signed by Microsoft in the case of &lt;code&gt;**PROCEXP152**.sys&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;code-block relative mt-6 first:mt-0 group/code&#34;&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;Sysmon schemaversion=&amp;#34;4.23&amp;#34;&amp;gt;
    &amp;lt;EventFiltering&amp;gt;
        &amp;lt;RuleGroup name=&amp;#34;&amp;#34; groupRelation=&amp;#34;or&amp;#34;&amp;gt;
            &amp;lt;DriverLoad onmatch=&amp;#34;include&amp;#34;&amp;gt;
                &amp;lt;ImageLoaded condition=&amp;#34;contains&amp;#34; name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34;&amp;gt;TempPROCEXP152.sys&amp;lt;/ImageLoaded&amp;gt;
                &amp;lt;Hashes condition=&amp;#34;is&amp;#34; name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34;&amp;gt;C06DDA757B92E79540551EFD00B99D4B&amp;lt;/Hashes&amp;gt;
            &amp;lt;/DriverLoad&amp;gt;
        &amp;lt;/RuleGroup&amp;gt;
        &amp;lt;RuleGroup name=&amp;#34;&amp;#34; groupRelation=&amp;#34;or&amp;#34;&amp;gt;
            &amp;lt;ImageLoad onmatch=&amp;#34;include&amp;#34;&amp;gt;
                &amp;lt;Signed name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;is&amp;#34;&amp;gt;false&amp;lt;/Signed&amp;gt;
                &amp;lt;ImageLoaded name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;is&amp;#34;&amp;gt;C:WindowsSystem32ntoskrnl.exe&amp;lt;/ImageLoaded&amp;gt;
            &amp;lt;/ImageLoad&amp;gt;
        &amp;lt;/RuleGroup&amp;gt;
        &amp;lt;RuleGroup name=&amp;#34;&amp;#34; groupRelation=&amp;#34;and&amp;#34;&amp;gt;
            &amp;lt;FileCreate onmatch=&amp;#34;include&amp;#34;&amp;gt;
                &amp;lt;TargetFilename name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;AppDataLocalTempPROCEXP152.sys&amp;lt;/TargetFilename&amp;gt;
            &amp;lt;/FileCreate&amp;gt;
&amp;lt;FileCreate onmatch=&amp;#34;exclude&amp;#34;&amp;gt;
                &amp;lt;Image condition=&amp;#34;contains&amp;#34;&amp;gt;procexp64.exe&amp;lt;/Image&amp;gt;
                &amp;lt;Image condition=&amp;#34;contains&amp;#34;&amp;gt;procexp.exe&amp;lt;/Image&amp;gt;
                &amp;lt;Image condition=&amp;#34;contains&amp;#34;&amp;gt;procmon64.exe&amp;lt;/Image&amp;gt;
                &amp;lt;Image condition=&amp;#34;contains&amp;#34;&amp;gt;procmon.exe&amp;lt;/Image&amp;gt;
            &amp;lt;/FileCreate&amp;gt;
        &amp;lt;/RuleGroup&amp;gt;
        &amp;lt;RuleGroup name=&amp;#34;&amp;#34; groupRelation=&amp;#34;or&amp;#34;&amp;gt;
            &amp;lt;RegistryEvent onmatch=&amp;#34;include&amp;#34;&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;PROCEXP152ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;RTCore64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;GdrvImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;ATSZIOImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;MsIo64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;MsIoImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;GLCKIo2ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;EneIo64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;EneIoImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;WinRing0x64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;WinRing0_1_2_0ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;EneTechIo64ImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;EneTechIoImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;NalDrvImagePath&amp;lt;/TargetObject&amp;gt;
                &amp;lt;TargetObject name=&amp;#34;MITRE_REF=T1014,NAME=Rootkit&amp;#34; condition=&amp;#34;contains&amp;#34;&amp;gt;HKLM~&amp;lt;/TargetObject&amp;gt;
            &amp;lt;/RegistryEvent&amp;gt;
        &amp;lt;/RuleGroup&amp;gt;
    &amp;lt;/EventFiltering&amp;gt;
&amp;lt;/Sysmon&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;opacity-0 transition group-hover/code:opacity-100 flex gap-1 absolute m-[11px] right-0 top-0&#34;&gt;
    &lt;button
      class=&#34;code-copy-btn group/copybtn transition-all active:opacity-50 bg-primary-700/5 border border-black/5 text-gray-600 hover:text-gray-900 rounded-md p-1.5 dark:bg-primary-300/10 dark:border-white/10 dark:text-gray-400 dark:hover:text-gray-50&#34;
      title=&#34;Copy code&#34;
    &gt;
      &lt;div class=&#34;group-[.copied]/copybtn:hidden copy-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;hidden group-[.copied]/copybtn:block success-icon pointer-events-none h-4 w-4&#34;&gt;&lt;/div&gt;
    &lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;A basic PowerShell script for incident responders to help perform analysis on target machines. The script simply recurses through the entire &lt;code&gt;HKLM&lt;/code&gt; registry space and checks for any executable data (by checking the PE header magic bytes and length of the entry).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://gist.github.com/thomjs/e7c5f6087ff646acf32dae89e9c7ecf2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://gist.github.com/thomjs/e7c5f6087ff646acf32dae89e9c7ecf2&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;References&lt;span class=&#34;absolute -mt-20&#34; id=&#34;references&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#references&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.dylan.codes/evading-sysmon-and-windows-event-logging/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.dylan.codes/evading-sysmon-and-windows-event-logging/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hfiref0x/KDU/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/hfiref0x/KDU/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://swapcontext.blogspot.com/2020/01/unwinding-rtcore.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://swapcontext.blogspot.com/2020/01/unwinding-rtcore.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eclypsium.com/wp-content/uploads/sites/2/2019/08/EXTERNAL-Get-off-the-kernel-if-you-cant-drive-DEFCON27.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://eclypsium.com/wp-content/uploads/sites/2/2019/08/EXTERNAL-Get-off-the-kernel-if-you-cant-drive-DEFCON27.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.secureauth.com/labs/advisories/gigabyte-drivers-elevation-privilege-vulnerabilities&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.secureauth.com/labs/advisories/gigabyte-drivers-elevation-privilege-vulnerabilities&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.fuzzysecurity.com/tutorials/expDev/23.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.fuzzysecurity.com/tutorials/expDev/23.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
  </channel>
</rss>
